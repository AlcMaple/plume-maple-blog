---
title: 基础知识
createTime: 2025/03/31 10:02:35
permalink: /JavaScript/u9a56jcz/
---
[toc]

# JavaScript简介

## 知识程度

- 了解：
- 熟悉：
- 掌握：
- 精通：

## JavaScript介绍

**JavaScript** 是一种**脚本语言**,也是一种嵌入式语言。所谓“脚本语言”，指的是它**不具备开发操作系统**的能力，而是只用来编写**控制**其他大型**应用程序**的“脚本”，实现动态应用。

## 为什么学习 JavaScript

- 操控浏览器的能力
- 广泛的使用领域
    1. 写前端、后端、小程序（微信、支付宝小程序等）、APP（安卓/苹果）
    2. node.js写网页后台的服务器
- 易学性

## JavaScript与ECMAScript的关系

ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。

## JavaScript的应用

1. 淘宝的放大镜效果：鼠标移动到图片，会对相应位置放大
2. 轮播图
3. 鼠标移动到目标处可以使目标处移动
4. 翻转效果：表面图片，鼠标移动到目标处，翻转后面是文字的详情
5. 图片的一个碰撞放大的效果，五张图，移动到第一张图，第一张图放大，另外四张图往右边挤一挤，但是总体大小不变
6. 验证码的更换：点击看不清，换一换的文字，则验证码文字和图片都更换
7. 正则表达式的应用：给条件；判断密码的强度
8. 弹窗
9. 跳动的文字：文字跳来跳去

# HTML中的Javascript

## `<script>`元素

```html
<script>
    console.log("</script>");
</script>
```

> 这段语句会报错
>
> `/`在字符串中会被当作是结束标签

# JavaScript语句、标识符

## 语句

JavaScript 程序的**单位是行**（line），也就是一行一行地执行。一般情况下，每**一行就是一个语句**

```js
var num = 10;
```

语句以分号结尾，**一个分号**就表示**一个语句结束**（分号其实可以不写）

## 标识符

标识符是由：字母、美元符号($)、下划线(_)和数字组成，其中数字不能开头

>**温馨提示**
>
>中文是合法的标识符，可以用作变量名（不推荐）

# 变量

```js
var num = 10; 

// 不引入第三个变量，两个变量的值交换
var a=21,b=14
a=a+b;
b=a-b;
a=a-b
```

## var关键字

- `var`声明作用域
```html
<body>
    <script>
        function test() {
            // 局部变量
            var name = '张三';
            // 全局变量
            age=18;
        }
        // 访问前需要先调用函数来定义变量
        test();
        console.log(age); // 18
        console.log(name); // <empty string>
    </script>
</body>
```

- `var`可以定义多个变量，用`,`分隔每个变量
```html
<body>
    <script>
        var a,
            b=18,
            c;
        a=10;
        c=20;
        console.log(a,b,c);
    </script>
</body>
```

> 定义多个变量时，插入换行和空格缩进只是为了有利于阅读理解

## 变量的重新赋值

```js
var num = 10;
num = 20;
```

## 变量提升（记！）

JavaScript 引擎的工作方式是，**先**解析代码，**获取所有被声明的变量**，**然后再一行一行地运行**。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

```js
console.log(num);
var num = 10; // 结果是undefined
```

> **注意**
>
> 提升声明，不包含赋值

## 作用域 *

1. 全局变量，不在函数内用`var`(可忽略)
2. 局部变量，在函数内用`var`(`ES6`引入块级变量`let`取代，`let`相当于`{}`定义变量)  

```js
// ES6引入
{
    var v=10
    let l=1;
}
console.log(v); // 10
console.log(l); // undefined

// 父级作用域
for(let i……){
    // 子级作用域
    let i=……;
}

// 子级作用域和父级作用域不相互影响；若子级和父级没有同名，子级可以用父级的变量
for (let i = 0; i < 10; i++) {
    let i=10;
    console.log(i); // 输出10个10
}

for (var i = 0; i < 10; i++) {
    // 此i与for的i不一样，作用域不同
    let i=10;
    console.log(i); // 输出10个10
}

// 暂时性锁区(let)
var v=10;
if(1){
    // v的作用域变成了let
    v=20; // 未定义就初始
    let v=1;
    console.log(v)
}

// let不能重定义
var v;
let v; 
console.log(v) // 报错，v同名
```

# const *

- `const`的作用域和`let`一样

## const声明基本类型

**值不可更改**

```js
const x=10;
x=20; // 错误，无法重新赋值给x
```

## const声明对象和数组

**本身不可变，属性可以修改**

```js
const obj={name:'John'}
obj.name='Jane'; // 可以修改对象的属性
obj.age=25; // 可以添加新的属性
obj={name:'Alice'}; // 错误，不可以重新赋值给常量obj
```

# JavaScript引入到文件

## 嵌入到HTML文件中

```html
<body>
	<script>
		var age = 20
	</script>
</body>
```

单击'test'时，弹出一个警告框提示“Happy”
```html
<a href="javascript:alert('Happy');">test</a>
```
>函数(方法)都要用`()`，`()`是方法的标志


单击网页中的一个按钮时，就会触发按钮的单击事件
```html
<input type="button" onclick="alert('Happy');" value="test">
```

## 引入本地独立JS文件

```html
<body>
    <script type="text/javascript" src="./itbaizhan.js">   	
    </script>
</body>
```

>`script`:脚本

## 引入网络来源文件

```html
<body>
	<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js">	</script>
</body>
```

# JavaScript注释与常见输出方式

## JavaScript注释

```js
// 这是单行注释

/*
 这是
 多行
 注释
*/
```

嵌入在HTML文件中的注释

```html
<!-- 注释 -->
```

## JavaScript输出方式 *

```js
// 在浏览器中弹出一个对话框,然后把要输出的内容展示出来,alert都是把要输出的内容首先转换为字符串然后在输出的
alert("要输出的内容");

document.write("要输出的内容"); /*网页显示（这里相当于写html内容了）*/

document.write('<b>这是加粗文本</b>');

// 在控制台输出内容
console.log("要输出的内容");
```

>`alter()`经常用于测试程序，是`window`(窗口)对象下的

# 数据类型

**记！六大数据类型：数值、字符串、布尔值、null、undefined、对象**

## 数据类型分类

JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 **Symbol 类型**的值和第八种 **BigInt类型**）

### 原始类型(基础类型)

```js
// 数值/字 类型
var age = 20;
//2. 字符串类型：被单引号或双引号包裹
var name = "尚学堂";
//3. 布尔类型
var learn = true;
```

### 合成类型(复合类型、引用)

对象：因为一个对象往往是**多个原始类型的值的合成**，可以看作是一个存放各种值的容器

```js
var user = {
    name:"尚学堂",
    age:20,
    learn:true
}
```

> **温馨提示**
>
> 至于`undefined`和`null`，一般将它们看成两个特殊值。
>
>`null`表示变量(对象或地址)不存在
>
>`undefined`表示声明的变量还未赋值时的默认值

### 引用数据类型

提供地址，通过传递地址去访问数据

## typeof运算符

**typeof（判断'基本'数据类型）**

### 数值返回number

```js
typeof 123 // "number"
```

>判断是否为数字，使用`isNaN`，若返回值为`true`则表示**非数字**
>
>`NaN`意指非数字

### 字符串返回string

```js
typeof '123' // "string"
```

### 布尔值返回boolean

```js
typeof false // "boolean"

// 布尔值为false的值：
// ""  0  NaN  null  undefined
```

### 对象返回object

```js
typeof {} // "object"
```

### null与undefined的区别

1. null：代表**对象**“没有”，指变量不存在
2. undefined：代表**数值**“没有”，指变量存在，但不知道值

- 应用
  1. 判断是否为数字

```js
type of value === "Number"
```



## undefined类型

当使用`var`或`let`声明了变量但没有初始化时，就相当于给变量赋予了`undefined`值

```html
<body>
    <script>
        let message;
        console.log(message == undefined); // true
    </script>
</body>
```

未声明的变量只能执行一个操作：`typeof`

```html
<body>
    <script>
        let message;
        console.log(typeof message); // undefined
        console.log(typeof age); // undefined
    </script>
</body>
```

## null型

逻辑上讲，`null`值表示一个**空对象**指针

```html
<body>
    <script>
        let message=null;
        console.log(typeof message); // object
    </script>
</body>
```

`null`值派生于`undefined`

```js
console.log(null==undefined); // true
```

## Number类型

- 作用：转换为数字

如果计算返回正`Infinity`或负`Infinity`，表示不能再进一步用于任何计算，即超出了`JavaScript`可以表示的范围

```html
<body>
    <script>
        let num = Number.MAX_VALUE + Number.MAX_VALUE;
        console.log(num); // Infinity
    </script>
</body>
```



不同的数据类型到数值的转换

```html
<body>
    <script>
        console.log(Number("Hello World")); // NaN
        console.log(Number("")); // 0
        console.log(Number("000011")); // 11
        console.log(Number(true)); // 1
    </script>
</body>
```



## parseInt方法

- 作用：解析字符串并转换为整数

- 语法：`parseInt(字符串，进制);`

- 参数
1. 字符串：你要转为整数的字符串
2. 进制：可选，该字符串是以什么进制来阅读，转化为10进制；默认十进制

```html
<body>
    <script>
        var a='10';
        var b='1010';

        console.log(parseInt(a)); // 10
        console.log(parseInt(b,2)); // 10
    </script>
</body>
```

```html
<body>
    <script>
        console.log(parseInt("1234blue")); // 1234
        console.log(parseInt("")); // NaN
        console.log(parseInt("0xA")); // 10
        console.log(parseInt(22.5)); // 22
        console.log(parseInt("70")); // 70
        console.log(parseInt("0xf")); // 15
    </script>
</body>
```



## BigInt()方法

- 作用：创建**任意精度**整数，能够处理超出JS常规整数范围的整数

```html
<body>
    <script>

        let v=10n;
        console.log(typeof(v)); // BigInt

        // 普通整数转换为BigInt
        console.log(BigInt(42)); // 42n

        // 字符串转换为十进制BigInt
        console.log(BigInt('123')); // 123n

        // 字符串转换为十六进制BigInt
        console.log(BigInt('0xFF')); // 255n

        // 字符串转换为二进制BigInt
        console.log(BigInt('0b110')); // 6n

        // 字符串转换为八进制BigInt
        console.log(BigInt('0o755')); // 493n

    </script>
</body>
```

> 后缀`n`表示这是`BigInt`类型，不会将其当成字符串

## 字符转整数

`'目标字符值'-'0'`

```js
'3' - '0' = 3 // 51-48=3
```

# 运算符之算术运算符

## 加减乘除运算符

```js
10 + 10; // 20
100 - 10; // 90
10 * 2; //20
10 / 5; //2
```

## 余数运算符

```js
13 % 5 // 3
```

## 自增和自减运算符

自增和自减运算符，是**一元运算符**，只需要**一个运算子**。它们的作用是将运算子首先转为数值，然后加上1或者减去1

```js
var x = 1;
var y = 1;
++x // 2
--y // 0
```

```js
var x = 1;
var y = 1;

console.log(x++) // 1
console.log(++y) // 2
```

```js
var x = 10;
var y = 20;
console.log(x++ + y);// 30
```

# 运算符之赋值运算符

```js
// 将 1 赋值给变量 x
var x = 1;

// 将变量 y 的值赋值给变量 x
var x = y;
```

```js
// 等同于 x = x + y
// 将运算符左边的变量加上 右边表达式 的值，然后赋值给左边的变量
x += y

// 等同于 x = x - y
x -= y

// 等同于 x = x * y
x *= y

// 等同于 x = x / y
x /= y

// 等同于 x = x % y
x %= y
```

# 运算符之比较运算符

```js
2 > 1 // true
```

## “ == ”和“ === ”的区别

==：双等比较**值**

===：三等比较**值和类型**

注："!=="表示为**不等于值和类型**

# 运算符之布尔运算符

## 取反运算符（!）

### 布尔值取反

```js
!true // false
!false // true
```



### 非布尔值取反

对于非布尔值，取反运算符会将其转为布尔值。可以这样**记忆**，以下六个值取反后为true，其他值都为false。

> **温馨提示**
>
> undefined
> null
> false
> 0
> NaN
> 空字符串（''）



```js
!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
```



## 且运算符（&&）



```js
console.log(10 < 20 && 10 >5); // true
```



## 或运算符（||）

```js
console.log(10 < 20 || 10 < 5); // true
```

# 运算符之in运算符

- 作用：判断属性是否存在于对象

```js
console.log('sex' in Person)
```

# 运算符之位运算符

## 左移位运算符

指将二进制数向左移动指定的位数，`<<1`相当于`*2`，其实是`1<<1`

- `1 << 1`表示将数字1的二进制形式`0001`向左移动一位，结果是`0010`，即十进制的2。
- 如果`n`是3，那么`1 << 3`表示将数字1的二进制形式`0001`向左移动三位，结果是`1000`，即十进制的8。这与`2^3`的结果一致。
- 因此得出结论：**`1<<n`是`2^n`**

## 右移位运算符

指将二进制数向右移动指定的位数，`>>1`相当于`/2`

## 异或运算符

- 应用：
1. 只出现一次的数字(当有一个数字出现超过2个，则不适用)

- 特点
1. 相同则为`0`，相反则为`1`
2. `a⊕0 = a`
3. `a⊕a = 0`
4. 交换律与结合律：`a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b`

```js
let result = 5 ^ 3; // 0101 ^ 0011 = 0110 (6)
```

```js
// 找出数组[0,n]中，没有出现在数组中的元素，n为数组的长度
var missingNumber = function (nums) {
    let xor = 0;
    for (num of nums) {
        xor ^= num;
    }
    for (let i = 0; i <= nums.length; i++) {
        xor ^= i;
    }
    return xor;
};
```

# 运算符之扩展运算符

```html
<body>
    <script>
        let arr=[1,2,33];
        // 将数组/字符串展开为独立的参数
        console.log(...arr); // 1 2 33
        // arr.forEach(element => {
        //    console.log(element); 
        // });
        console.log(Math.max(...arr)); // 33
        
        let str="112233";
        console.log(...str); // 1 1 2 2 3 3 
        
        console.log('--------------------------------------------------------------');

        // 合并新的数组或对象
        console.log([...str]); // ['1','1','2','2','3','3']

        let arr2=[5,6,8,7];
        console.log([...arr,...arr2]); // [1,2,33,5,6,8,7]

        let obj={
            name:'张三',
            age:18
        }

        let obj2={
            hobby:'篮球'
        }
        console.log({...obj,...obj2}); // { name:'张三',age:18,hobby:'篮球' }
    </script>
</body>
```

# 条件语句之 if语句

## if语句语法规范

```js
if (布尔值){
   语句; 
}
```

需要注意的是，“布尔值”往往由一个**条件表达式**产生的，**必须**放在**圆括号中**

```js
var m = 3;
if (m === 3) {
    m++;
}
console.log(m); // 4
```

```js
var x = 1;
var y = 2;
if (x = y) {//不小心等号写成赋值，所造成的结果是：x被赋值为2然后为真，则输出2
    console.log(x);
}
```

**语句与表达式的区别**

>有返回值的是表达式，例如：变量
>
>无返回值的是语句，例如：`for`、`if`

### 实时效果反馈

**2. 下列代码运行结果是:**

```js
var num1 = "10"
var num2 = 10;
if(num1 _===__ num2){
    console.log("num1等于num2"); // 无打印
}
```

# 条件语句之 if...else

## if...else基本结构

```js
if (m === 3) {
  // 满足条件时，执行的语句
} else {
  // 不满足条件时，执行的语句
}
```

## 多个if...else连接


```js
if (m === 0) {
  // ...
} else if (m === 1) {
  // ...
} else if (m === 2) {
  // ...
} else {
  // ...
}
```

## if...else嵌套

```js
var eat = true;
var food = "猪肉炖粉条";
if (eat) {
    if (food == "双椒鱼头") {
        console.log('双椒鱼头');	
    }else{
        console.log("猪肉炖粉条");
    }
} else {
    console.log('不吃了');
}
```

**else**代码块总是与**离自己最近**的那个if语句**配对**。

### 实时效果反馈

**1.下列条件语句中，横线处应填写代码是 ：**

```js
var eat = true;
var food = "猪肉炖粉条";
if (eat) {
    if (food _！=__ "双椒鱼头") {    
        console.log('双椒鱼头'); // 打印双椒鱼头
    }else{
        console.log("猪肉炖粉条");  
    }
} else {
    console.log('不吃了');
}
```

# 条件语句之 switch

**多个if...else**连在一起使用的时候，可以转为使用更方便的**switch**结构


```js
switch (fruit) {
  case "banana":
    // ...
    break;
  case "apple":
    // ...
    break;
  default:
    // ...
}
```

需要注意的是，每个case代码块内部的**break语句不能少**，否则会接下去执行下一个case代码块，而不是跳出switch结构。

```js
var x = 1;

switch (x) {
  case 1:
    console.log('x 等于1');
  case 2:
    console.log('x 等于2');
  default:
    console.log('x 等于其他值');
}
// x等于1
// x等于2
// x等于其他值
```

# 三元运算符 

JavaScript还有一个三元运算符（即该运算符需要三个运算子）`?:`，也可以用于逻辑判断。

```js
(条件) ? 表达式1 : 表达式2
```

这个三元运算符可以被视为**if...else...的简写**形式，因此可以用于多种场合。



## 判断一个整数是奇数与偶数

### if...else语句

```js
var n = 100;
if (n % 2 === 0) {
  console.log("偶数");
} else {
  console.log("奇数");
}
```

### 三元运算符

```js
var n = 100;
n % 2 === 0 ? '偶数' : '奇数'
```

# 循环语句之for

称为**计次**循环语句，一般用于**循环次数已知**的情况

格式如下

```js
for (初始化表达式; 条件; 迭代因子) {
  语句
}
```

for语句后面的括号里面，有三个表达式。

1. **初始化**表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。

2. 布尔表达式（test）：每轮循环开始时，都要执行这个**条件表达式**，只有值为真，才继续进行循环。

3. 迭代因子（increment）：每轮循环的最后一个操作，通常用来**递增循环变量**。

```js
var x = 3;
for (var i = 0; i < x; i++) {
  console.log(i);
}
```

for语句的三个表达式，可以省略任何一个，也可以全部省略。

```js
for ( ; ; ){
  console.log('Hello World');
}
```

> **温馨提示**
>
> 如果三个都省略，结果就导致了一个无限循环（死循环）

- `for`、`while`、`do-while`的区别

> `for(;;)`，可以设置循环次数，知道明确循环次数
> 
> `while()`，不明确循环次数
> 
> `do-while`，先运行一次再走循环

## for...in循环遍历对象的属性 **

- 作用：遍历对象

>对于**for……in**的知识学习将在**对象**中详细**介绍**

```js
var a = ['sxt', 'baizhan', 'it'];

for (var i in a) {/* 相当于 var i = 0; i < a.length; i++ */  /* i为属性名 */
  console.log(a[i]);
}
```

## forEach()方法 *

用于**调用数组**的每个元素，并将元素传递给回调函数

语法:`array.forEach(callbackFn(currentValue, index, arr), thisValue)`

| 参数                                 |                                描述                                 |
| :----------------------------------- | :-----------------------------------------------------------------: |
| callbackFn(currentValue, index, arr) |                 必写，数组中每个元素需要调用的函数                  |
| currentValue                         |                           必写，当前元素                            |
| index                                |                       可写，当前元素的索引值                        |
| arr                                  |                      可写，当前元素所属的数组                       |
| thisValue                            | 可写，传递给函数的值，一般用“this”；若这个参数为空，默认为undefined |

多种语法形式
```js
// 箭头函数
forEach((element) => { /* … */ })
forEach((element, index) => { /* … */ })
forEach((element, index, array) => { /* … */ })

// 回调函数
forEach(callbackFn)
forEach(callbackFn, thisArg)

// 内联回调函数
forEach(function(element) { /* … */ })
forEach(function(element, index) { /* … */ })
forEach(function(element, index, array){ /* … */ })
forEach(function(element, index, array) { /* … */ }, thisArg)
```

```html
<body>
    <button onclick="arr.forEach(myFunction)">点我</button>
    <p>总和为:<span id="num"></span></p>

    <hr>

    <p>乘以：<input type="number" id="chengfa" value="10"></p>
    <button onclick="arr1.forEach(Tname)">点我</button>

    <p>计算之后的值为：<span id="answer"></span></p>
    <script>
        // 计算数组所有元素相加之和
        var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        var sum = 0
        function myFunction(itme) {
            sum += itme
            document.getElementById("num").innerHTML = sum

        }

        //数组中的所有值乘以特定的数字
        var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        function Tname(itme, index, arr1) { //name不能作为函数名 -> 关键字
            arr1[index] = itme * document.getElementById("chengfa").value
            document.getElementById("answer").innerHTML = arr1
        }

        // continue实现
        var arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        arr2.forEach(function (item) {
            if (item === 3) {
                return; //forEach支持return语句，但是它不是代表退出循环，而是退出当前回调函数，会执行下一次循环
            }
            console.log(item);
        })

        console.log("==========================================================");

        //break实现
        /* var arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
         arr3.forEach(function(item){
             console.log(item);
             return item!==3 //return false并不会退出循环
         })*/

        var arr5 = [1, 2, 3, 4, 5];
        var num = 3;
        arr5.every(function (v) { // foreach无法实现break，可以通过every来实现break
            if (v == num) {
                return false;
            } else {
                console.log(v);
                return true;
            }
        });

    </script>
</body>
```

>**注意**
>
>空数组不会执行回调函数
>
>该方法的返回值是`undefined`
>
>forEach()方法不存在`break`和`continue`

## for...of循环(ES6)

- 作用：遍历数组中的每一个元素，并对**每个元素执行**循环体中的**操作**

```js
for(const i of prices){
    ans=Math.max(ans,i-minValue)
    minValue=Math.min(minValue,i)
}
```

## for循环语句实操

### 循环输出1~100之间数字的和

```js
var sum=0;
for(var i=1;i<=100;i++){
    sum+=i;
}
console.log(sum);
```

### 循环输出1000以内的奇数

```js
for(i = 0 ; i<1000; i ++){
    if( i % 2 ==1){
        console.log( i + " ");   
    }
}
```

### 打印九九乘法表

```js
for(var i = 1;i <= 9;i++){
    document.write("<br>"); 
    for(var j = 1;j <= i;j++){
        sum = i * j;
        document.write(i ,"*",j ,"=",sum," ");
    }
}
```

>一个for循环是线，两个for循环是面，三个for循环是体（看**变量**数）

# 循环语句之while

```js
while (条件) {
  语句;
}
```

## while例子

```js
var i = 0;
while (i < 100) {
  console.log('i 当前为：' + i);
  i = i + 1;
}
```

下面的例子是一个无限循环，因为循环条件总是为真

```js
while (true) {
  console.log('Hello, world');
}
```

所有for循环，都可以改写成while循环

```js
// for
var x = 3;
for (var i = 0; i < x; i++) {
  console.log(i);
}

// while
var x = 3;
var i = 0;
while (i < x) {
  console.log(i);
  i++;
}
```

# break 语句和 continue 语句

## break

```js
for (var i = 0; i < 5; i++) {
    if (i === 3){
        break;
    }
    console.log(i);
}
```

## continue

```js
for (var i = 0; i < 5; i++) {
    if (i === 3){
        continue;
    }
    console.log(i);
}
```

# 字符串

```js
'itbaizhan'
"itbaizhan"
```

**单引号**字符串的**内部**，可以**使用双引号**。**双引号**字符串的**内部**，可以**使用单引号**

```js
'key = "value"'
"It's a long itbaizhan"
```

如果要在**单引号**字符串的**内部**，**使用单引号**，就必须在**内部的单引号前**面**加**上**反斜杠**，用来转义。**双引号字符串内部使用双引号，也是如此**

```js
'Did she say \'Hello\'?'
// "Did she say 'Hello'?"

"Did she say \"Hello\"?"
// "Did she say "Hello"?"
```

> **温馨提示**
>
> 字符串默认只能写在一行内，分成多行将会报错

如果**长字符串**必须分成**多行**，可以在**每一行的尾部使用反斜杠**

```js
var longString = 'Long \
long \
string';

// " Long long string"
```

```js
// 字符串拼接
alter('220'+'230')  // 220230

alter('220+230='+220+230); // 220+230=220230

alter('220+230='+(220+230)); // 220+230=450
```

## length 属性

```js
var s = 'itbaizhan';
s.length // 9
```

## 模板字符串

通过使用 反引号 ` 

用来定义多行字符串&在字符串中加入变量和表达式

### 普通字符串

```js
let string = `Hello\nWorld`
console.log(string);
```

### 多行字符串

```js
        let string1=`Hello,
ta jing ran bao kuo le zhe li de huan hang
        can you studip?`
        console.log(string1);
```


>**注意**
>
>在使用模板字符串的时候，空格和换行会被保留

### 字符串插入变量和表达式

```js
let name='Mike'
let age =22
let string2=`My name is ${name},age is ${age}`
console.log(string2);
```


>`${}`:通过jQuery语句引用变量


### 字符串中调用函数

```js
function message() {
    return 'have fun!'
}
let string3=`game start!${message()}`
console.log(string3);
```

## 字符串方法_charAt()

`charAt`方法返回指定位置的字符，参数是从`0`开始编号的

```js
var s = new String('itbaizhan'); // new：创建一个实例对象

s.charAt(1) // "t"
s.charAt(s.length - 1) // "n"
```

如果参数为负数，或大于等于字符串的长度，`charAt`返回空字符串

```js
'itbaizhan'.charAt(-1) // ""
'itbaizhan'.charAt(9) // ""
```

> 用`new`修饰函数，此函数为构造函数

```js
function students(){
    this.name="haha"
    this.age=18
}

let zhangsan= new students();
```

> `charCodeAt(index)`:获取该值的ASCII码
> 
> `str[index]`:与`charAt`一样

## 字符串方法_concat()

`concat`方法用于**连接两个字符串**，返回一个新字符串，不改变原字符串

```js
var s1 = 'itbaizhan';
var s2 = 'sxt';

s1.concat(s2) // "itbaizhansxt"
s1 // "itbaizhan"
```

该方法可以接受多个参数

```js
'sxt'.concat('itbaizhan', 'bjsxt') // "sxtitbaizhanbjsxt"
```

如果参数不是字符串，`concat`方法会将其先转为字符串，然后再连接

```js
var one = 1;
var two = 2;
var three = '3';

''.concat(one, two, three) // "123"
```

## 字符串方法_substring()

`substring`方法用于从原字符串**取出子字符串**并返回，**不改变原字符串**。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）

```js
'itbaizhan'.substring(0, 2) // "it"
```

如果省略第二个参数，则表示子字符串一直到原字符串的结束

```js
'itbaizhan'.substring(2) // "baizhan"
```

如果第一个参数大于第二个参数，`substring`方法会自动更换两个参数的位置

```js
'itbaizhan'.substring(9, 2) // "baizhan"
// 等同于
'itbaizhan'.substring(2, 9) // "baizhan"
```

如果参数是负数，`substring`方法会自动将负数转为0

```
'itbaizhan'.substring(-3) // "itbaizhan"
'itbaizhan'.substring(2, -3) // "it"
```

## 字符串方法_substr()

`substr`方法用于从原字符串取出子串并返回，**不改变原字符串**，跟`substring`方法的作用相同

`substr`方法的第一个参数是子字符串的开始位置（从0开始计算），**第二个参数是子字符串的长度**

```js
'itbaizhan'.substr(2, 7); // baizhan
```

如果省略第二个参数，则表示子字符串一直到原字符串的结束

```js
'itbaizhan'.substr(2) // "baizhan"
```

如果**第一个参数是负数**，表示**倒数计算的字符位置**。如果**第二个参数是负数**，将被自动转为0，因此会返回**空字符串**

```js
'itbaizhan'.substr(-7) // "baizhan"
'itbaizhan'.substr(4, -1) // ""
```

## 字符串方法_indexOf()

`indexOf`方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回`-1`，就表示不匹配

```js
'hello world'.indexOf('o') // 4
'itbaizhan'.indexOf('sxt') // -1
```

`indexOf`方法还可以接受第**二个参数**，表示从**该位置开始向后匹配**

```js
'hello world'.indexOf('o', 6) // 7
```

>`lastIndexOf()`:从后面开始查找

## 字符串方法_trim()

`trim`方法用于去**除字符串两端**的空格，返回一个新字符串，**不改变原字符串**

```js
'  hello world  '.trim()
// "hello world"
```

该方法**去除**的不仅是空格，还包括制表符（`\t`、`\v`）、换行符（`\n`）和回车符（`\r`）

```js
'\r\nitbaizhan \t'.trim() // 'itbaizhan'
```

扩展方法，`trimEnd()`和`trimStart()`方法

```js
"   itbaizhan   ".trimEnd(); //    itbaizhan
"   itbaizhan   ".trimStart(); // itbaizhan   
```

## 字符串方法_split()

`split`方法按照给定规则将字符串分割成一个个字串，规则处断开，**返回一个由分割**出来的子字符串**组成的数组**

```js
'it|sxt|baizhan'.split('|') // ["it", "sxt", "baizhan"]
```

如果分割**规则为空字符串**，则返回**数组**的成员是原字符串的**每一个字符**。

```js
'a|b|c'.split('') // ["a", "|",  "b","|", "c"]
```

如果**省略参数**，则返回数组的唯一成员就是**原字符串**

```js
'it|sxt|bz'.split() // [it|sxt|bz]
```

`split`方法还可以接受**第二个参数**，限定返回数组的**最大成员数**。

```js
'it|sxt|bz'.split('|', 0) // []
'it|sxt|bz'.split('|', 1) // ["it"]
'it|sxt|bz'.split('|', 2) // ["it", "sxt"]
'it|sxt|bz'.split('|', 3) // ["it", "sxt", "bz"]
'it|sxt|bz'.split('|', 4) // ["it", "sxt", "bz"]
```

## 字符串方法_toLowerCase()

- 作用：将字符串中所有大写字母变成小写字母

> **注意**
>
> 使用此方法，任何小写字母、非字母的字符不受影响
>
> 返回一个新的字符串，不改变原有字符串

## 字符串方法_fromCharCode()

- 作用：将指定的`Unicode`值转换为字符串，返回一个字符串

- 语法：`String.fromCharCode(n1,n2,n3,……,nX)`

**将 Unicode 编码转为一个字符**
```js
var n = String.fromCharCode(65);
console.log(n); // A
```

**将 Unicode 编码转换为一个字符串**
```js
var n = String.fromCharCode(72,69,76,76,79);
console.log(n); // HELLO
```

# 数组

数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用**方括号表示**。

## 数组的创建

1. `let arr1=new Array()`
2. `let arr2=[]`  --------常用

```js
var arr = ['sxt', 'baizhan', 'it'];
```


```js
var arr = [];

arr[0] = 'sxt';
arr[1] = 'baizhan';
arr[2] = 'it';
```


```js
var arr = [ 100, [1, 2, 3],false ];
```

如果数组的元素还是数组，就形成了多维数组

```js
var a = [[1, 2], [3, 4]];
a[0][1] // 2
a[1][1] // 4
```

## length 属性

数组的length属性，**返回**数组的**成员数量**

```js
['sxt', 'baizhan', 'it'].length // 3
```

> **注意**
>
> `length`可以赋值，影响原数组

## 数组的遍历

```js
var a = ['sxt', 'baizhan', 'it'];

// for循环
for(var i = 0; i < a.length; i++) {
  console.log(a[i]);
}

// while循环
var i = 0;
while (i < a.length) {
  console.log(a[i]);
  i++;
}
```

## 数组方法_splice方法

`splice`方法用于**添加或删除**数组的元素，并返回删除的数组。

>注意：此方法会修改原数组

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2,0,"Lemon","Kiwi");

console.log(fruits); // Banana,Orange,Lemon,Kiwi,Apple,Mango

var sites=['Runoob','Google','Taobao']
sites.splice(2,1);
// ["Taobao"]
```

## 数组静态方法_Array.isArray()

`Array.isArray`方法返回一个布尔值，表示参数**是否为数组**。它可以弥补`typeof`运算符的不足

```js
var arr = ["尚学堂", 100, true];
console.log(typeof arr); // object
```

```js
var arr = ['sxt', 'baizhan', 'it'];
Array.isArray(arr) // true
```

- `instanceof`(实例)

`arr instanceof Array`

> 结果返回`true`或者`false`

## 实时效果反馈

**1. 下列代码输出分别是？：**

```js
var arr = ["尚学堂", 100, true];
var str = "itbaizhan";
console.log(typeof arr);
console.log(Array.isArray(arr));
console.log(typeof str);
console.log(Array.isArray(str));
```

object  true  string  false

## 数组方法_push()/pop()

`push`方法用于在数组的**末端添加一个或多个元素**，并**返回**添加新元素后的**数组长度**。注意，该方法会改变原数组

```js
var arr = [];
arr.push("尚学堂") // 1
arr.push('itbaizhan') // 2
arr.push(true, {}) // 4
arr // [尚学堂, 'itbaizhan', true, {}]
```

`pop`方法用于**删除**数组的**最后一个**元素，并**返回该元素**。注意，该方法会改变原数组

```js
var arr = ['尚学堂', 'itbaizhan', 'WEB前端'];

arr.pop() // 'WEB前端'
arr // ['尚学堂', 'itbaizhan']
```

## 数组方法_shift()/unshift()

`shift`方法用于**删除数组的第一个元素**，并**返回该元素**。注意，该方法会改变原数组

```js
var arr = ['尚学堂', 'itbaizhan', 'WEB前端'];

arr.shift() // '尚学堂'
arr // ['itbaizhan', 'WEB前端']
```

`shift`方法可以遍历并清空一个数组

```js
var list = [1, 2, 3, 4, 5, 6];
var item;

while (item = list.shift()) {/* 数组里没元素就返回undefined，即退出循环 */
  console.log(item);
}

list // []
```

`unshift`方法用于在**数组的第一个位置添加元素**，并**返回**添加新元素后的数组**长度**。注意，该方法会改变原数组

```js
var arr = ['尚学堂', 'itbaizhan', 'WEB前端'];

arr.unshift('baizhan'); // 4
arr // ['baizhan', '尚学堂', 'itbaizhan', 'WEB前端']
```

`unshift`方法**可以**接受**多个参数**，这些参数都会添加到目标数组头部

```js
var arr = [ '尚学堂', 'itbaizhan' ];
arr.unshift('WEB前端', 'baizhan') // 4
arr // [ 'WEB前端', 'baizhan', '尚学堂', 'itbaizhan' ]
```

## 数组方法_join() **

`join`方法以指定参数作为拼接，将所有数组成员连接都加上这个拼接参数并最终为一个**字符串返回**。如果不提供参数，默认用逗号拼接（注：**不改变原数组**）

```js
var a = [1, 2, 3, 4];

// 1+' '+2+' '+3+' '+4
a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"
```

如果数组成员是`undefined`或`null`或空位，会被转成空字符串

```js
[undefined, null].join('#')
// '#'

['a',, 'b'].join('-')
// 'a--b'
```

数组的`join`配合字符串的`split`可以实现数组与字符串的互换

```js
var arr = ["a","b","c"];
var myArr = arr.join("");
console.log(myArr);
console.log(myArr.split(""));
```

> `toString`:数组转字符串，默认用`,`链接
>
> `toString`接受一个参数，用于表示以什么进制转换为字符串.例如`toString(2)`,则输出的是二进制展示的字符串

```js
let num = 10;
let binaryString = num.toString(2);
console.log(binaryString); // 输出 "1010"
```



## 实时效果反馈

**1. 下列关于数组输出的结果是：**

```js
var arr = ["尚学堂","百战程序员"];
var myArr = arr.join("");
console.log(myArr);
console.log(myArr.split(""));
```

尚学堂百战程序员   ['尚', '学', '堂', '百', '战', '程', '序', '员']





## 数组方法_concat()

`concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后面，然后返回一个新数组，**原数组不变**

```js
['hello'].concat(['world'])
// ["hello", "world"]

['hello'].concat(['world'], ['!'])
// ["hello", "world", "!"]
```

除了数组作为参数，`concat`也接受其他类型的值作为参数，添加到目标数组尾部。

```js
[1, 2, 3].concat(4, 5, 6)
// [1, 2, 3, 4, 5, 6]
```

> **应用场景**
>
> 上拉加载，合并数据

## 实时效果反馈

**1. 下列关于数组输出的结果是：**

```js
[1, 2, 3].concat(4, 5, 6,[7,8,9])
```

`[1, 2, 3, 4, 5, 6, 7, 8, 9]`

## 数组方法_reverse()


`reverse`方法用于**颠倒排列数组元素**，返回改变后的数组。注意，该方法将**改变原数组**

```js
var a = ['a', 'b', 'c'];

a.reverse() // ["c", "b", "a"]
a // ["c", "b", "a"]
```

实现一个字符串反转排列

```js
var str = "hello";
str.split("").reverse().join("")
```






## 数组方法_indexOf() *


`indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回`-1`

```js
var arr = ['a', 'b', 'c'];

arr.indexOf('b') // 1
arr.indexOf('y') // -1
```

`indexOf`方法还可以接受第二个参数，表示搜索的开始位置

```js
['尚学堂', '百战程序员', 'itbaizhan'].indexOf('尚学堂', 1) // -1
```

## 实时效果反馈

**1. 下列关于数组方法，运行正确结果是：**

```js
var arr = ["尚学堂", "it", "itbaizhan","it"];
arr.indexOf("it",2)
```

3

> **说明**
>
> 如果想从后往前查找：lastIndex

## 数组方法_fill()

将一个固定值替换数组的元素(一般用来暂时填充空数组)

语法：`array.fill(value,start,end)`

array:数组名
value:填充的值(必填)
start:开始位置
end:结束位置，默认为array.length

```js
// var arr=[];
var arr=new Array(4)
arr.fill(0);
console.log(arr);

var arr1=[1,1,1,1]
arr1.fill(0,2,4);
console.log(arr1);
```

## 数组方法_from()

- 语法
1. `Array.from(arrayLike)`
2. `Array.from(arrayLike,mapFn)`
3. `Array.from(arrayLike,mapFn,thisArg)`

>`Array.from(arrayLike,mapFn,thisArg)` <=> `Array.from(arrayLike).map(mapFn,thisArg)`

>**参数**
>
>`arrayLike`：要转换为数组的对象，并不是指数据类型是对象
>
>`mapFn`:调用该函数并将返回值添加到数组,即对正在创建的数组的每一个元素执行一个函数
>
>`thisArg`:是指定`mapFn`函数的`this`，如果不传入则this指向全局对象`Windows`对象

- 返回值：`一个新的Array实例`

来自数组的数组

```js
Array.from([1,2,3])
// [1,2,3]
```

来自字符串的数组

```js
Array.from('foo');
// [ "f", "o", "o" ]
```

集合中的数组
```js
const set=new Set(['foo', 'bar', 'baz', 'foo']);
Array.from(set);
// [ "foo", "bar", "baz" ]
```

- `const`不能声明，只能初始化

> `const`是常量，不能重新赋值，
>
> 在声明时同时要初始化
>
> 否则声明的常量无意义`(undefined)`

来自map的数组
```js
const map=new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
Array.from(map);
// [[1,'x'], [2, 'y'], [3, 'z']]

const mapper=new Map([['a', 1], ['b', 2]]);
Array.from(mapper,values());
// [1, 2]

Array.from(mapper,key());
// ["a", "b"]
```

NodeList中的数组
```js
const images=document.querySelectorAll('img');
const sources=Array.from(images,(image)=>image.src);
// Array.filter方法：筛选数组中符合条件的元素
// 将sources里以http://开头的元素过滤出来并添加到insecureSources数组中
const insecureSources=sources.filter((link)=>link.startsWith('http://'));
```

来自类数组对象的数组(参数)
```js
function f(){
    // arguments：类数组对象，用于接收传入的参数
    return Array.from(arguments);
}

f(1,2,3);
// [1,2,3]
```

使用箭头函数和Array.from()
```js
Array.from([1,2,3],(x)=>x+x);
// [2,4,6]

// length:5 -> 表示要创建五个元素的数组
// 第二个参数：表示对正在创建的数组的每一个元素执行一个函数,箭头函数的i是索引值，每次都把索引值返回给值
/*
    * i是索引值由于from源码里的for循环结构实现的
    * Array.from = function(arrayLike, mapFn, thisArg) {
    * // 1. 尝试将传入的参数转换成对象，如果会抛出异常就直接返回空数组
    * var items = Object(arrayLike);
  
    * // 2. 获取要返回数组的长度
    * var len = items.length >>> 0;
  
    * // 3. 如果没有传入 mapFn 参数，就使用默认的映射函数
    * if (typeof mapFn !== 'function') {
    *   mapFn = function(item) { return item; };
    * }
    * var arr = new Array(len);
      for (var i = 0; i < len; i++) {
          arr[i] = mapFn(items[i], i);
      }
*/
Array.from({length:5},(v,i)=>i);
// [0,1,2,3,4]
```

## 数组方法_entries()

- 作用：返回一个数组的迭代对象，包含数组的键值对

```js
for (const [i, word] of arr.entries()) { // is
        const ch = pattern[i];
        if (ch2word.has(ch) && ch2word.get(ch) != word || word2ch.has(word) && word2ch.get(word) != ch) {
            return false;
        }
        ch2word.set(ch, word);
        word2ch.set(word, ch);
    }
```



## 排序

### sort方法

```js
const nums=[1,30,4,21,100000]
console.log(nums)
// 运用sort方法，底层是comepareFn比较函数   
nums.sort(function(a,b){
    return a-b; //从小到大
})
console.log(nums)
```


- 与默认排序的方式的区别
> 默认方式：将数组元素**转换为字符串**，然后按字典顺序**排序**

**默认排序方式**
```js
nums1.sort();
```

### 冒泡排序

```js
let arr=[10,7,5,27,98,31] // 待排序数组

// 控制需要比较的轮数
for(let i=1;i<arr.length;i++){
    // 控制参与比较的元素
    for(let j=0;j<arr.length-i;j++){
        // 比较相邻的两个元素
        if(arr[j]>arr[j+1]){
            let temp=arr[j+1]
            arr[j+1]=arr[j]
            arr[j]=temp
        }
    }
}
console.log(arr); // 输出结果为：5，7，10，27，31，98
```

### 数组方法_map()

- 作用：对数组中的每个元素进行操作，并**返回一个新的数组**

- 语法：`array.map(function(currentValue,index,arr),thisValue)`

- 参数说明
1. `function`:回调函数，对数组每个元素进行操作
2. `currentValue`:当前正在处理的元素
3. `index`:当前正在处理元素的索引
4. `arr`:要操作的那个数组
5. `thisValue`:可选参数，传入回调函数的参数，默认指向全局对象`Windows`

```html
<body>
    <script>
        const object_data = {
            name: '小明',
            age: 18
        }

        var test = 5;

        var arr = [1, 2, 3, 4, 5, 6];
        // const new_arr = arr.map(function (num, index, arr) {
        //     return num + index;
        // }, object_data)
        // console.log(new_arr); // 1 3 5 7 9 11

        // const new_arr = arr.map(function (num, index, arr) {
        //     return num + arr[index];
        // }, object_data)
        // console.log(new_arr); // 2 4 6 8 10 12

        // const new_arr = arr.map(function (num, index, arr) {
        //     return this.age;
        // }, object_data)
        // console.log(new_arr);// 18 18 18 18 18 18

        const new_arr = arr.map(function (num, index, arr) {
            return num*test;
        }, test)
        console.log(new_arr);// 5 10 15 20 25 30
    </script>
</body>
```

- 创建二维数组

```js
let row = 5
let col = 7
let arr = new Array(row).fill(0).map( () => new Array(col).fill(0) )
```

- 前者fill(0)是必要的，如果没有它会报错，map方法会跳过这些空位置，不执行回调函数
- 没有它，创建的数组是一个“稀疏数组”，数组的元素是空的，并且不是undefined值，就是真正意义上的空

## 求中点

在程序的世界，如果是奇数，我们取的中点就是中点；如果是偶数，我们取的中点是两个数的左边那个数

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let left = 0
        let right = arr.length - 1 // 9

        // 通过位运算符去求解，最好的方式，位运算符可以直接操作二进制数据
        // >>1 相当于 /2
        let mid = ((right - left) >> 1) + left
        console.log(arr[mid]); // 5
        
        // 是下面的优化，把求和改成了相差，也能解决溢出问题，但是没有位运算高效
        let mid_three = Math.floor((right - left) / 2) + left
        console.log(arr[mid_three]); // 5

        // 求和的方式，有极限，若一边是接近无限，再加一个数就会溢出
        let mid_two = Math.floor((left + right) / 2)
        console.log(arr[mid_two]); // 5
    </script>
</body>

</html>
```



# 函数

本质：对象

```js
students.ha="hi"
console.log(students.ha)
```

## 函数的声明(定义)

`function` 命令： function命令声明的代码区块，就是一个函数。function命令**后面是函数名**，函数名后面是一对**圆括号**，里面是传入函数的**参数**。**函数体**放在**大括号**里面。

```js
function print(s) {
  console.log(s);
}
```

## 函数名的提升

`JavaScript` 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会**像变量声明一样，被提升到代码头部**

```js
add();

function add() {}
```

- 变量无法提升函数

```js
v()
var v=function(){
    console.log('v')
}

// 报错的原因：
/*
    一行一行代码运行，此时把变量v的声明提升了，
    但函数此时还没赋值，
    无法通过v()调用函数的形式
    因为undefined()是错误的
*/
```

## 函数参数

```js
function square(x) {
	console.log(x * x);
}

square(2) // 4
square(3) // 9
```

- 形参`arguments`:保存所有形参，**返回数组**

```js
function sum(){
    console.log(arguments);
    let score=0
    for(let i=0;i<arguments.length;i++){
        score=score+arguments[i]
    }
    return score
}
console.log(sum(1,2))
```

## 函数返回值

```js
function getName(name){
    return name;
}

var myName = getName("itbaizhan")
console.log(myName); // itbaizhan
```

> **温馨提示**
>
> `return` 后面不能在添加任何代码，因为不会执行
>
> `function`函数不需要返回类型，根据数据类型自动分配

```js
function f(n1,n2,n3){
    return n1+n2+n3
}
console.log(f(1,2)) // NaN
```

>数字+`undefined(n3)` => 非数字 => `NaN`

## 函数表达式

`var f=count();`

# 对象概述 *

什么是对象？对象（object）是 JavaScript 语言的**核心概念**，也是**最重要的数据类型**，是**属性和方法的集合**

简单说，对象就是**一组“键值对”（key-value）的集合**，是一种**无序的复合数据集合**

- 数组与对象的区别
1. 数组：通过索引去访问
2. 由**属性(本质：字符串)**和方法共同构成

```js
var user = {
  name: 'itbaizhan',
  age: '13'
};
```

对象的每一个**键名又称为“属性”**（property），它的“键

值”可以是任何数据类型。如果一个**属性的值为函数**，通常把这个属性称为 **“方法”**，它可以像函数那样调用

```js
var user = {
  getName: function (name) {
    return name;
  },
//   getName: function() {
//     var name='itbaizhan';
//     return name;
//   },//user.getName();
//   getName(){
//     var name='itbaizhan';
//     return name;
//   },//user.getName();
//   getName:function temp(){
//     var name='itbaizhan';
//     return name;
//   },//user.getName();
//   getName:function temp02(temp03){
//     return temp03;
//   },//user.getName("itbaizhan");
};
user.getName("itbaizhan") // itbaizhan
```

如果属性的值还是一个对象，就形成了链式引用

```js
var user = {
    name:"itbaizhan",
    age:13,
    container:{
        frontEnd:["Web前端","Android","iOS"],
        backEnd:["Java","Python"]
    }
}
user.container.frontEnd // ["Web前端","Android","iOS"]
```

## 对象属性的访问方式

```js
var obj = {
    name: '王五',
    age: 22,
    obj_obj: {
        name: '王五'
    },
    obj_fun: function () {
        console.log('我的名字是王五，年龄为22岁');
    },
    obj_temp: function () {
        console.log('temp');
    },
    obj_temp02: function (temp03) {
        console.log('我是终极套哇');
    }
}
// 访问一
console.log(obj.name);
// 访问二
console.log(obj['name']);
// 访问三
console.log(obj["obj_temp"]());
```

## 数组与对象的区别

> 前者：通过索引去访问，后者由属性和方法共同构成
>
> 一般规定样式上的属性用`attribute`，对象上的属性用`property`，仅此用这个来区分

# Math对象

## Math.abs()

**`Math.abs`方法返回参数值的绝对值**

```js
Math.abs(1) // 1
Math.abs(-1) // 1
```



## Math.max()，Math.min()

`Math.max`方法返回参数之中最大的那个值，`Math.min`返回最小的那个值。如果参数为空, `Math.min`返回`Infinity`, `Math.max`返回`-Infinity`。

```js
Math.max(2, -1, 5) // 5
Math.min(2, -1, 5) // -1
Math.min() // Infinity,意指无穷大
Math.max() // -Infinity
```



## Math.floor()，Math.ceil() *

`Math.floor`方法返回小于参数值的最大整数

```js
Math.floor(3.2) // 3
Math.floor(-3.2) // -4
```

> 可以通过这个方法，获取整数(即小数转整数)
> 这个方法可以替代`//`，能够整除

`Math.ceil`方法返回大于参数值的最小整数

```js
Math.ceil(3.2) // 4
Math.ceil(-3.2) // -3
```



## Math.random() *

`Math.random()`返回0到1之间的一个伪随机数，可能等于0，但是一定小于1

```js
Math.random() // 0.28525367438365223
```

**任意范围**的随机数生成函数如下

```js
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

getRandomArbitrary(5, 10)
```

## Math.pow(),Math.sqrt(),Math.round()

- `Math.pow`:指数
- `Math.sqrt`:开根
- `Math.round`:四舍五入

# Date对象

`Date`对象是 JavaScript 原生的时间库。它**以1970年1月1日00:00:00作为时间的零点**，可以表示的时间范围是前后各1亿天（单位为毫秒）

> **注意**
>
> 日期对象**需要实例化**

## Date.now()

`Date.now`方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000

```js
Date.now();   // 1635216733395
```



## 时间戳

时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。

格林威治和北京时间就是时区的不同

Unix是20世纪70年代初出现的一个操作系统，Unix认为1970年1月1日0点是时间纪元。JavaScript也就遵循了这一约束



`Date`对象提供了一系列`get*`方法，用来获取实例对象某个方面的值

> **实例方法get类**
>
> getTime()：返回实例距离1970年1月1日00:00:00的毫秒数
> getDate()：返回实例对象对应每个月的几号（从1开始）
> getDay()：返回星期几，星期日为0，星期一为1，以此类推
> getYear()：返回距离1900的年数
> getFullYear()：返回四位的年份
> getMonth()：返回月份（0表示1月，11表示12月）
> getHours()：返回小时（0-23）
> getMilliseconds()：返回毫秒（0-999）
> getMinutes()：返回分钟（0-59）
> getSeconds()：返回秒（0-59）

```js
var d = new Date('January 6, 2022');
d.getDate() // 6
d.getMonth() // 0
d.getYear() // 122
d.getFullYear() // 2022
```

编写函数获得**本年度剩余天数**

```js
function leftDays() {
  var today = new Date();
  var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999);
  var msPerDay = 24 * 60 * 60 * 1000;
  return Math.round((endYear.getTime() - today.getTime()) / msPerDay);
}
```

# 正则表达式

## 创建一个正则表达式

```html
<body>
    <script>
        // 两种创建方式
        // 1.正则表达式字面量，由斜杠之间组成，用于正则表达式保持不变
        let re=/ab+c/;
        // 2.调用RegExp对象构造函数，用于动态产生正则表达式
        let re2=new RegExp('ab+c');
    </script>
</body>
```

## 编写一个正则表达式的模式

- 正则表达式中的特殊字符

| 字符    | 含义                                                                                                                                                   |
| :------ | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `\`     | 转义字符                                                                                                                                               |
| `^`     | 匹配输入的开始，例如：`/^A/`匹配`"An E"`中的`A`                                                                                                        |
| `$`     | 匹配输入的结束，例如：`/t$/`匹配`"eat"`的`t`                                                                                                           |
| `*`     | 匹配前一个字符的`0`个或多个，例如：`/bo*/`会匹配`"A ghost boooooed"`中的`'booooo'`和`"A bird warbled"`中的`'b'`                                        |
| `+`     | 匹配前一个字符的`1`个或多个，例如：`/a+/`会匹配`"candy"`中的`'a'`和`"caaaaaaandy"`中所有的`'a'`                                                        |
| `?`     | 匹配前一个字符的`0`个或`1`个，例如：`/e?le?`会匹配`"angel"`中的`'el'`、`"angle"`中的`'le'`以及`"oslo'`中的`'l'`                                        |
| `x\|y`  | 匹配`x`或者`y`，例如：`/green\|red/`匹配`“green apple”`中的`‘green’`和`“red apple”`中的`‘red’`                                                         |
| `{n,}`  | 匹配前一个字符至少出现了`n`次，例如：`/a{2,}/`匹配`"aa"`,`"aaaa"`和`"aaaaa"`                                                                           |
| `[xyz]` | 匹配方括号中的任意字符，包括转义字符，可以使用`-`来指定范围，例如：`[abcd]`和`[a-d]`是一样的。他们都匹配`"brisket"`中的`‘b’`,也都匹配`“city”`中的`‘c’` |
| `\d`    | 匹配一个数字，等价于`[0-9]`，例如,`/\d/`或者`/[0-9]/`,配`"B2 is the suite number."`中的`'2'`                                                           |
| `\D`    | 匹配一个非数字字符，等价于`[^0-9]`，例如`/\D/`或者`/[^0-9]/匹配"B2 is the suite number."`中的`'B'`                                                     |

```js
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  //$&表示整个被匹配的字符串

var re = /\w+\s/g;

// 替换
var re = new RegExp("\\w+\\s", "g");
}
```

> `g`：表示全局搜索选项或标记，将在整个字符串查找到的所有匹配结果进行返回

## 使用正则表达式

| 方法      | 描述                                                                       |
| :-------- | :------------------------------------------------------------------------- |
| `exec`    | 在一个字符串中查找匹配`RegExp`方法，返回一个数组，否则返回`null`           |
| `match`   | 在一个字符串中查找匹配`String`方法,返回一个数组，否则返回`null`            |
| `search`  | 在字符串中匹配`String`方法，返回匹配到的索引，否则返回`-1`                 |
| `replace` | 在字符串中匹配`String`方法，并使用替换字符串替换匹配到的字串               |
| `split`   | 使用正则表达式或者一个固定字符串分隔一个字符串，将分隔的字符串存储到数组中 |


# DOM概述

**DOM** 是 JavaScript 操作网页的**接口**，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如对元素增删内容）

浏览器会根据 DOM 模型，将结构化文档**HTML解析成一系列的节点**，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口

DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言

## 属性操作 *

通过`.`运算符获得属性，无法获得自定义的属性(返回`undefined`)

### element.getAttribute('属性名')

返回指定属性名的`属性值`，包括自定义属性

### element.setAttribute('属性名', '属性值')

设置元素的属性名和属性值

> **注意**
>
> `element.getAttribute`和`element.setAttribute`所有属性自动全部转小写

### element.removeAttribute('属性名')

移除元素属性

## 自定义属性 *

> 属性名前加`data-`(这是命名规范,使用`data-`命名的会放在`dataset`集合里面)
> 
> `data-`作用：能够使用`.`运算符或者`[]`，例如：`element.dataset.属性名`
>
> 用`.`就能用`[]`，是因为它是对象
>
> 使用`.`运算符的属性名是小写，并且不带前缀
>
> 创建自定义属性：`element.dataset.laoHao='haha'`or`element.dataset.laohao='haha'`
>
> 以上两种创建方式的属性将变成`data-lao-hao`和`data-laohao`，`H`会转换成`-h`

## Node节点

DOM 的最小组成**单位叫做节点（node）**。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子(即网页中所有内容都是节点，节点封装成对象)

节点的类型有七种

> `Document`：整个文档树的顶层节点
> 
> `DocumentType`：`doctype`标签
> 
> `Element`：网页的各种`HTML`标签,`notetype`为`1`
> 
> `Attribute`：网页元素的属性（比如`class="right"`）,`notetype`为`2`
> 
> `Text`：标签之间或标签包含的文本,`notetype`为`3`
> 
> `Comment`：注释,`notetype`为`8`
> 
> `DocumentFragment`：文档的片段

## 节点树

一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树

浏览器原生提供document节点，代表整个文档

```js
document
// 整个文档树
```

## 节点层级

除了根节点，其他节点都有三种层级关系

> 父节点关系（parentNode）：直接的那个上级节点
> 
> 子节点关系（childNodes）：直接的下级节点
> 
> 同级节点关系（sibling）：拥有同一个父节点的节点

### parentNode()

返回离某节点最近父节点，若指定的节点没有父节点则返回`NULL`

语法:`node.parentNode`

返回`<li>`元素的父节点
```html
<body>
    <ul id="father">
        <li>Coffee</li>
        <li>Tea</li>
        <li>Drink</li>
    </ul>
    <p id="output">点按钮返回li标签的父节点</p>
    <button onclick="Myfunction()">按钮</button>
    <script>
        function Myfunction() {
            var liNodes=document.getElementById("father").childNodes[0];
            output.innerHTML=liNodes.parentNode.nodeName;
        }
    </script>
</body>
```

### childNodes

获得所有子节点，包括其他类型的节点

### children

children属性返回子元素的集合

根据子元素在元素中出现的先后顺序进行排序，使用`length`可以获得子元素的数量

**children和childNodes的区别**
1. `childNodes`:返回**所有节点**，**包括文本节点**、注释节点
2. `children`:只返回**元素节点**

```html
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .mydiv{
            height: 800px;
            width: 800px;
            background-color: red;
        }

        .mydiv div:nth-child(1){
            height: 100px;
            width: 100px;
            background-color: blue;
        }

        .mydiv div:nth-child(2){
            height: 100px;
            width: 100px;
            background-color: black;
        }

        .mydiv div:nth-child(3){
            height: 100px;
            width: 100px;
            background-color: white;
        }

        .mydiv div:nth-child(4){
            height: 100px;
            width: 100px;
            background-color: aqua;
        }
    </style>
</head>
<body>
    <div class="mydiv">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>

    <div class="mydiv1">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>

    <select name="" id="select">
        <option value="11">11</option>
        <option value="22">22</option>
        <option value="33">33</option>
        <option value="44">44</option>
    </select>
    <script>
        // 获取body元素的子元素集合
        var divs=document.body.children
        console.log(divs);

        // 查看div有几个子元素
        var mydiv=document.querySelector('.mydiv');
        var divs1=mydiv.children.length
        console.log(divs1);

        // 修改div元素第二个子元素的背景颜色
        var div1=document.querySelector('.mydiv');
        var div2=div1.children;
        console.log(div2.nodeName);
        div2[1].style.backgroundColor="yellow";

        //获取 select 元素中第三个(索引为 2) 子元素的文本
        var select=document.querySelector('select');
        var select1=select.children[2];
        select1.innerText="第三个";

        //修改 body 元素所有子元素的背景颜色
        var divs2=document.body.children;
        for(var i=0;i<divs2.length;i++){
            divs2[i].style.backgroundColor="green";
        }

    </script>
</body>
```

### firstElementChile和lastElementChild

返回第一个和最后一个子元素节点

### nextSibling和previousSibling

返回下一个和上一个的兄弟节点，包括其他类型节点

### insertBefore()方法 *

- 作用：在已有的子节点前插入一个新的子节点

- 语法：`node.insertBefore(newnode,existingnode)`

- 参数：
1. `newnode`:必须，要插入的节点对象
2. `existingnode`:必须，要添加新的节点前的子节点(这是一个**参考节点**)

> 没有子节点的情况下，会把新节点添加为现有节点的第一个子节点

## Node.nodeType属性

```js
document.nodeType // 9
document.nodeType === Node.DOCUMENT_NODE // true
```

## Element对象_属性

### Element.id

`Element.id`属性返回指定元素的`id`属性，该属性**可**读**写**

```js
// HTML 代码为 <p id="foo">
var p = document.querySelector('p');
p.id // "foo"
```

### Element.className

`className`属性用来读写当前元素节点的`class`属性。它的值是一个字符串

```js
// HTML 代码 <div class="one two three" id="myDiv"></div>
var div = document.getElementById('myDiv');
div.className
```

### Element.classList *

`classList`对象有下列方法

> - `add()`：增加一个 class。
> - `remove()`：移除一个 class。
> - `contains()`：检查当前元素是否包含某个 class。
> - `toggle()`：将某个 class 移入或移出当前元素。

```js
var div = document.getElementById('myDiv');

div.classList.add('myCssClass');
div.classList.add('foo', 'bar');
div.classList.remove('myCssClass');
div.classList.toggle('myCssClass'); // 如果 myCssClass 不存在就加入，否则移除
div.classList.contains('myCssClass'); // 返回 true 或者 false
```

### 创建节点 *

#### element.createElement()

#### Element.innerHTML

`Element.innerHTML`属性返回一个字符串。该属性可读写，**常用来**设置某个节点的内容。它能改写所有元素节点的内容，包括`<HTML>`和`<body>`元素

```js
el.innerHTML = '';
```

#### Element.innerText

`innerText`和`innerHTML`类似，不同的是`innerText`**无法识别元素**，会**直接渲染成字符串**

`innerText`和`textContent`类似，不同的是`innerText`会被`CSS`样式影响

#### Element.textContent

> 忽视`HTML`、`CSS`，保留格式的文本

## Element获取元素位置

| 属性         |                                     描述                                      |
| :----------- | :---------------------------------------------------------------------------: |
| clientHeight |          获取元素高度包括`padding`部分，但是不包括`border`、`margin`          |
| clientWidth  |          获取元素宽度包括`padding`部分，但是不包括`border`、`margin`          |
| scrollHeight | 元素总高度，它包括`padding`，但是不包括`border`、`margin`包括溢出的不可见内容 |
| scrollWidth  | 元素总宽度，它包括`padding`，但是不包括`border`、`margin`包括溢出的不可见内容 |
| scrollLeft   |                      元素的水平滚动条向右滚动的像素数量                       |
| scrollTop    |                      元素的垂直滚动条向下滚动的像素数量                       |
| offsetHeight |    元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border     |
| offsetWidth  |    元素的 CSS 水平宽度（单位像素），包括元素本身的高度、padding 和 border     |
| offsetLeft   |                            到定位父级左边界的间距                             |
| offsetTop    |                            到定位父级上边界的间距                             |

`offsetWidth/Height`:获取或设置元素的宽高(不含滚动条)
`scrollWidth/Height`:获取或设置元素的**完整的**宽和高(**含滚动条**)

`offsetTop/Left`:获取或设置包含滚动条，距离上或左边滚动过的距离


### Element.clientHeight，Element.clientWidth

`Element.clientHeight`属性返回一个整数值（单位像素），只对**块级元素生效**，对于行内元素返回`0`。

`Element.clientWidth`块级元素有效。

`document.documentElement`的`clientHeight`属性，返回当前视口的高度（即**浏览器窗口的高度**）。`document.body`的高度则是**网页的实际高度**。

```js
// 视口高度
document.documentElement.clientHeight

// 网页总高度
document.body.clientHeight
```



### Element.scrollHeight，Element.scrollWidth

`Element.scrollHeight`单位像素

`Element.scrollWidth`单位像素，其他地方都与`scrollHeight`属性类似。这两个属性**只读**

整张网页的总高度可以从`document.documentElement`或`document.body`上读取

```js
// 返回网页的总高度
document.documentElement.scrollHeight
document.body.scrollHeight
```



### Element.scrollLeft，Element.scrollTop

`Element.scrollLeft`属性表示当前元素的水平滚动条向右侧滚动的像素数量，`Element.scrollTop`属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些**没有滚动条**的网页元素，这两个属性总是**等于0**

如果要查看整张网页的水平的和垂直的滚动距离，要从`document.documentElement`元素上读取

```js
document.documentElement.scrollLeft
document.documentElement.scrollTop
```



### Element.offsetHeight，Element.offsetWidth

`Element.offsetHeight`，`Element.offsetWidth`这两个属性都是只读属性，如果元素的 CSS 设为不可见（比如`display: none;`），则返回`0`



### Element.offsetLeft，Element.offsetTop

`Element.offsetLeft`返回当前元素**左上角**相对于`Element.offsetParent`节点的水平位移，`Element.offsetTop`返回垂直位移，单位为像素。通常，这**两个值是指相对于父节点**的位移

```html
<div class="parent">
    <div class="box" id="box"></div>
</div>
```

```css
.parent{
    width: 200px;
    height: 200px;
    background: red;
    position: relative;
    left: 50px;
    top: 50px;
}

.box{
    width: 100px;
    height: 100px;
    background: yellow;
    position: relative;
    left: 50px;
    top: 50px;
}
```

```js
var box = document.getElementById("box");
console.log(box.offsetLeft);
console.log(box.offsetTop);
```

## DOM元素对象

1. `appendChild()`
2. `insertBefore()`:为当前节点增加一个子节点(插入到指定子节点之前)
3. `removeChild()`:删除当前节点的某个子节点
4. `append()`

### 添加和删除节点

#### appendChild()

#### cloneNode()方法

拷贝所有属性和值

如果传递参数是`true`(深拷贝)，则将递归复制当前节点的所有子孙节点，否则只复制当前节点(浅拷贝)

#### removeChild()方法

从子节点列表中删除某个节点

若删除成功，返回被删除的节点；否则返回NULL

语法:`node.removeChild(node)`

>参数`node`必写

从子节点列表中删除某个节点

```html
<body>
    <ul id="list">
        <li>Coffee</li>
        <li>Tea</li>
        <li>Milk</li>
    </ul>
    <p>点按钮删除列表一个节点</p>
    <button onclick="Myfunction()">按钮</button>
    <script>
        var list = document.getElementById("list");
        function Myfunction() {

           // list.removeChild(list.childNodes[0]) //点击两次才清除一个节点的原因是因为，
            //`childNodes`属性返回包括文本节点在内的所有子节点，所以第一个节点是换行符

            // list.removeChild(list.childNodes[1])
 
            console.log(list.removeChild(list.children[0]));
             //通过children属性可以清除元素子节点
        }
    </script>
</body>
```

### nodeName属性

依据节点的类型返回其名称

语法:`node.nodeName`

获取body元素的节点名
```html
<body>
    <p id="pp"></p>
    <script>
        console.log(document.body.nodeName);
        var p=document.getElementById("pp");
        console.log(p.nodeName);
    </script>
</body>
```


### append()

- 与`appendChild()`区别：
1. 可以添加多个节点和字符串，`appendChild()`只能添加一个节点

```js
append(param1);
append(param1,param2);
append(param1,param2,/* ..., */paramN);
```

>当节点无法插入到父节点时，会抛出错误：`HierarchyRequestError DOMException`

追加一个元素
```js
let div = document.createElement("div");
let p = document.createElement("p");
div.append(p);

console.log(div.childNodes); // NodeList [ <p> ]
```

追加文本
```js
let div = document.createElement("div");
div.append("Some text");

console.log(div.textContent); // "Some text"
```

附加元素和文本
```js
let div = document.createElement("div");
let p = document.createElement("p");
div.append("Some text", p);

console.log(div.childNodes); // NodeList [ #text Some text, <p> ]
```

>进阶理解
```js
// 新建图片节点
/**
    * 作用：生成音乐播放器中的图片轮播效果
    */
this._mImgDomArr = Array.from(
    // length+2 的目的是 为了在图片列表的前后各添加一张图片 从而 实现图片轮播效果
    new Array(this._imgSrcArr.length + 2),
    (item, index) => {
        // 添加图片标签
        const dom = document.createElement("img");
        switch (index) {
            case 0:
                // 当播放到第一张图片时，切换到最后一张
                dom.src = this._imgSrcArr[this._imgSrcArr.length - 1];
                break;
            case this._imgSrcArr.length + 1:
                // 当播放到最后一张图片时，切换到第一张
                dom.src = this._imgSrcArr[0];
                break;
            default:
                // 播放第一首歌时，切换到第一张图片，即index-1:数组从0开始
                dom.src = this._imgSrcArr[index - 1];
                break;
        }
        return dom;
    }
);
// 将所有的图片添加到该元素的子节点
// ...:指将每个元素作为单独的参数传递给append方法，使得img标签依次添加到图片容器中
this._mImgContentDom.append(...this._mImgDomArr);
```

# document对象_方法/获取元素

- 访问指定节点
1. `getElementById()`
2. `getElementsByName()`
3. `getElementsByTagName()`
4. `getElementsByClassName()`

## document.getElementsByTagName()

`document.getElementsByTagName`方法**搜索 HTML 标签名**，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection`实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集

```js
var paras = document.getElementsByTagName('p');
```

如果传入`*`，就可以**返回文档中所有 HTML 元素**

```js
var allElements = document.getElementsByTagName('*');//不包含开头和最后两个
```

## document.getElementsByClassName()

`document.getElementsByClassName`方法返回一个类似数组的对象（`HTMLCollection`实例），包括了**所有`class`名字符合指定条件的元素**，元素的变化实时反映在返回结果中

```js
var elements = document.getElementsByClassName(names);
```

由于`class`是保留字，所以 JavaScript 一律使用`className`表示 CSS 的`class`

参数可以是**多个`class`，它们之间使用空格分隔**

```js
var elements = document.getElementsByClassName('foo bar');//并不是foo类名和bar类名，而是类名里包含了foo和bar，至于顺序无所谓
```



## document.getElementsByName()

`document.getElementsByName`方法用于选择**拥有`name`属性的 HTML 元素**（比如`<form>`、`<radio>`、`<img>`等），返回一个类似数组的的对象（`NodeList`实例），因为`name`属性相同的元素可能不止一个

```js
// 表单为 <form name="itbaizhan"></form>
var forms = document.getElementsByName('itbaizhan');
```



## document.getElementById()

`document.getElementById`方法返回匹配**指定`id`属性的元素节点**。如果没有发现匹配的节点，则返回`null`

```js
var elem = document.getElementById('para1');//无法向下寻找，只能向上寻找
```

注意，该方法的参数是大小写敏感的。比如，如果某个节点的`id`属性是`main`，那么`document.getElementById('Main')`将返回`null`



## document.querySelector()

`document.querySelector`方法
>接受一个**CSS选择器**作为参数，返回匹配该选择器的元素节点。如果有**多个节点满足**匹配条件，则**返回第一个**匹配的节点。如果没有发现匹配的节点，则返回`null`
接受一个**标签**作为参数

```js
var el1 = document.querySelector('.myclass');
```
```js
    //html <p id="foo"></p>
        console.log(document.querySelector('p'));
//<p id="foo">
```



## document.querySelectorAll()

`document.querySelectorAll`方法**与`querySelector`用法类似**，区别是**返回**一个`NodeList`对象，**包含所有匹配给定选择器的节点**
```js
var elementList = document.querySelectorAll('.myclass');
```


# document对象_方法/创建元素

- 创建节点
1. `createElement()`
2. `createTextNode()`

## document.createElement()

`document.createElement`方法用来**生成元素节点**，并**返回该节点**

```js
var newDiv = document.createElement('div');
```



## document.createTextNode()

`document.createTextNode`方法用来**生成文本节点**（`Text`实例），并**返回该节点**。它的**参数是文本节点的内容**

```js
var newDiv = document.createElement('div');
var newContent = document.createTextNode('Hello');
newDiv.appendChild(newContent);//将内容或子元素放到容器中
```



## document.createAttribute()

`document.createAttribute`方法**生成**一个**新的属性节点**（`Attr`实例），并返回它

```js
var attribute = document.createAttribute(name);
```
```html
<div id="root" itbaizhan="qaq"></div>
```
```js
var root = document.getElementById('root');
var it = document.createAttribute('itbaizhan');
it.value = 'it';
root.setAttributeNode(it);
```

# DOM事件对象

## 事件处理程序(事件监听)

事件处理程序分为：

1. HTML事件处理
2. DOM0级事件处理
3. DOM2级事件处理

### HTML事件

```html
<!DOCTYPE html>
<html>
    <head lang="en">
        <meta charset="UTF-8">
        <title>Js事件详解--事件处理</title>
    </head>
    <body>
        <div id="div">
            <!-- 鼠标点击 -->
            <button id="btn1" onclick="demo()">按钮</button>
        </div>
        <script>
            function demo(){
                alert("hello html事件处理");
            }
        </script>
    </body>
</html> 
```

### DOM0级事件处理

```html
<body>
    <div id="div">
        <button id="btn1">按钮</button>
    </div>
    <script>
        var btn1=document.getElementById("btn1");
        //onclick
        btn1.onclick=function(){alert("Hello DOM0级事件处理程序1");}//被覆盖掉
        btn1.onclick=function(){alert("Hello DOM0级事件处理程序2");}
    </script>
</body>
```

### DOM2级事件处理

#### element.addEventListener()

- 作用：能给同一元素设置多个不同的或相同的事件

- 语法:`element.addEventListener(event,callback,useCapute)`

- 参数
1. `event`:事件类型
2. `callback`:回调函数，即事件触发时所执行的函数
3. `useCapute`:完成冒泡或者捕获事件处理，默认为`false`

    useCapute
    1、值为true:执行捕获事件处理，从外到里
    2、值为false:执行冒泡事件处理，从里到外

```html
<body>
    <div id="div">
        <button id="btn1">按钮</button>
    </div>
    <script>
        var btn1=document.getElementById("btn1");
        // 添加事件监听
        btn1.addEventListener("click",demo1);
        btn1.addEventListener("click",demo2);
        btn1.addEventListener("click",demo3);
        function demo1(){
            alert("DOM2级事件处理程序1")
        }
        function demo2(){
            alert("DOM2级事件处理程序2")
        }
        function demo3(){
            alert("DOM2级事件处理程序3")
        }
        btn1.removeEventListener("click",demo2);
    </script>
</body>
```

#### element.removeEventListener()

- 作用：移除事件监听

> 对于提供了处理类型的事件，要分开移除

**传统的移除事件方式**
```js
btn.onclick=function(){}

btn.onclick=null
```

## 实时效果反馈

**1. 下列代码，是属于哪种事件处理方式：**

```js
btn2.addEventListener('click',function(){
	console.log("触发事件");
})
```

<font style="background-color:#8bc34a">C</font>   DOM2级事件处理

## DOM事件流

> 事件流：节点间按特定事件传播

- 执行步骤：捕获模式->冒泡模式

## Event事件对象

事件发生以后，会产生一个事件对象(`event`)，作为参数传给监听函数。

> `event`:跟事件有关的数据的集合

### Event对象常见属性和方法

1. `Event.Target`:返回触发事件的对象
2. `Event.type`
3. `e.stopPropagation`：阻止事件冒泡
4. `e.preventDefault`：阻止默认事件(应用：停止`a`，停止`form`)

#### Event.target

Event.target属性返回事件当前所在的节点

```js
// HTML代码为
// <p id="para">Hello</p>
function setColor(e) {
  console.log(this === e.target);
  e.target.style.color = 'red';
}

para.addEventListener('click', setColor);
```

> 与`this`的区别
>
> `e.target`:触发事件的对象
>
> `this`:绑定事件的对象

#### Event.type

Event.type属性返回一个字符串，**表示事件类型**。事件的类型是在生成事件的时候。该属性只读

```html
    <p id="para">Hello</p>
```
```js
//Event.target
        function setColor(e) {
            console.log(this == e.target);
            e.target.style.color = 'red';
            //Event.type
            console.log(e.type);


        }
        para.addEventListener('click', setColor);
```


### Event对象方法

1. Event.preventDefault()
2. Event.stopPropagation()



#### Event.preventDefault

event.preventDefault():阻止html标签本身具备的功能

```js
btn.onclick = function(e){
    e.preventDefault(); // 阻止默认事件
    console.log("点击A标签");
}
```



#### Event.stopPropagation()

event.stopPropagation:只发生一次，后续全部阻止

```js
btn.onclick = function(e){
    e.stopPropagation(); // 阻止事件冒泡
    console.log("btn");
}
```

## 事件代理(事件委托)

**事件会在冒泡阶段向上传播到父节点**，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）

>冒泡阶段：事件发生时，事件就开始传播（从里到外/从外到里）。
因为事件可能并没有处理这个事件的能力，就会传播到父级去处理

**事件冒泡**

```html
<div id="outer">
      <div id="inner">
          <button id="btn">Click me</button>
      </div>
</div>
<script src="./index.js"></script>
```

```js
const outer = document.querySelector("#outer");
const inner = document.querySelector("#inner");
const btn = document.querySelector("#btn");
outer.addEventListener("click", function () {
    console.log("Outer div clicked");
});
inner.addEventListener("click", function () {
    console.log("Inner div clicked");
});
btn.addEventListener("click", function () {
    console.log("Button clicked");
});
```

```js
var ul = document.querySelector('ul');

ul.addEventListener('click', function (event) {
    //toLowerCase或toUpperCase不能省写
    //tagName：返回元素的标签名称
    //toLowerCase：将大写字母→小写字母
  if (event.target.tagName.toLowerCase() === 'li') {
    // some code
  }
});
```

```js
<div class="phase-buttons" id="phaseSelection">
    <button data-phase="A">A面</button>
    <button data-phase="B">B面</button>
    <button data-phase="C">C面</button>
    <button data-phase="D">D面</button>
    <button data-phase="E">E面</button>
</div>

<script>
    document.getElementById("phaseSelection").addEventListener("click", function(event) {
        // 判断点击的是否是 button 元素
        if (event.target.tagName === "BUTTON") {
            const phase = event.target.dataset.phase; // 获取 data-phase 的值
            console.log("你点击了：" + phase + " 面");
        }
    });
</script>

```

在父标签定义事件，当我点击他的子按钮的时候，触发的事件会告诉我点击了哪个按钮

### 鼠标事件的常用方法

#### contextmenu禁止右键菜单

`oncontextmenu` 事件在元素中**用户右击鼠标**时触发并**打开上下文菜单**。

当`oncontextmenu`为false，无法点击右键

```html
<body oncontextmenu="return true">
</body>
```

>**注意**
>
>所有浏览器都支持`oncontextmenu`,但`contextmenu`只有`Firefox`才能用

#### selectstart禁止鼠标选中

```js
/* 获取需要操控的元素 */
var span=document.querySelector('.loading .firing span');
// console.log(span);

/** 禁止文本选中 */
span.addEventListener('selectstart',function (el) {
    el.preventDefault();
})
```

## 事件类型之鼠标事件

应用：图片跟着鼠标移动

### 鼠标事件

1. click：按下鼠标时触发
`注意：click:按住不会触发`
2. dblclick：在同一个元素上双击鼠标时触发
3. mousedown：按下鼠标键时触发
`注意：mousedown：按就触发`
4. mouseup：释放按下的鼠标键时触发
`注意：mouseup：与click的区别，右键释放也会触发；而click右键不会触发`
5. mousemove：当鼠标在节点内部**移动**时触发。
6. wheel：滚动鼠标的滚轮时触发
7. mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件
8. mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件
(鼠标**移动到某个**设置了此事件的元素上时触发)
9. mouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件
10. mouseout:鼠标从某个设置了此事件在元素上**离开**时触发


>**理解**
>
>`mouseenter`:在鼠标指针穿过被选元素时，才会触发。穿过其他任何子元素，不会触发，反之`mouseover`会


```js
var btn1 = document.getElementById("btn1");
btn1.onclick = function(){
    console.log("click事件");
}
```

> **温馨提示**
>
> 这些方法在使用的时候，除了DOM2级事件，都需要添加前缀`on`

## 实时效果反馈

**1. 下列是关于事件代理的处理，横线处应该填写的代码是：**

```js
var parent = document.getElementById("parent");
parent.addEventListener("click",function(e){
    if(e.___.tagName.___ === 'li'){
        console.log(e.target.innerHTML);
    }
})
```

target    
toLowerCase()

# BOM && 异步

## BOM(浏览器对象模型)

核心对象：`window`(全局对象)

独立于内容，与浏览器窗口进行交互，把浏览器当作对象

### BOM的组成

`BOM`包含`DOM`

### Window对象

window对象：表示整个浏览器的窗口，用于获取浏览器窗口的大小、位置和设置定时器等

- 常用的属性
1. `document`
2. `history`
3. `location`


- 常用的方法
1. `alert()`
2. ` confirm()`
3. `setTimeout()`
4. `clearTimeout()`
5. `setInterval()`
6. `clearInterval()`
7. `requestAnimationFrame()`：高效涉及到`DOM`操作或`canvas`绘制的动画执行

- 应用
1. 轮播图：使用方法3、5

#### window.onload窗口加载事件 *

窗口(页面)加载事件，**当文档内容(包括图像、脚本文件、css文件等)完全加载完成会触发事件**

传统方式:`window.onload=function(){};`

事件监听：`window.addEventListener('load',function(){});`

> 传统方式只能写一次，多次以最后一次为准
>
> 事件监听的方式无限制

**没有使用window.onload()方法------而报错**
```html
<!DOCTYPE html>   
<html>   
<head>   
<meta charset=" utf-8">   
<title>没有使用 window.onload() 测试</title>
<style type="text/css">
#bg{
    width:120px;
    height:120px;
    border:4px solid blue;
}
</style>
<script type="text/javascript">
document.getElementById("bg").style.backgroundColor="#F00";
</script>
</head>
<body>
    <div id="bg"></div>
</body>
</html>
```

**上述代码使用window.onload()------可执行**
```html
<!DOCTYPE html>   
<html>   
<head>   
<meta charset=" utf-8">   
<title>使用 window.onload() 测试</title>
<style type="text/css">
#bg{
    width:120px;
    height:120px;
    border:4px solid blue;
}
</style>
<script type="text/javascript">
window.onload=function(){
    document.getElementById("bg").style.backgroundColor="#F00";
}
</script>
</head>
<body>
    <div id="bg"></div>
</body>
</html>
```

**window.onload 与 jQuery ready() 区别**

```js
window.onload = function () {};    // JavaScript 
$(document).ready(function () {}); // jQuery
```

>**理解**
>
>`$(document).ready(function () {}); `
>
>1、`$`是**jQuery(函数)**的简写；`$()`是一个选择器，`document`是`html`的所有元素，`$(document)`返回一个数组，这个数组是一个对象，这个对象调用`ready()`，`function`是`ready`里的参数。
>
>**------作用**
>
>等页面全部加载完成之后执行写入的js，并且**写入的特效不与下一个里面写入的特效冲突**，因此可以在一个页面加载多个`js`
>
>**-----简写**
>
>`$(function(){})`
>
>2、`ready()`函数用于在当前文档结构载入完毕后立即执行指定的函数
>
>3、`$(document).ready(function () {}); `是在页面加载完所有`DOM`节点文档结构**和jQuery文件**后开始执行，`window.onload`在页面加载所有资源后才开始执行
>
>`(document).ready()`可以省略
>
>4、`window.onload`在定义时，只有最后一个有效，`$(function(){})`可以定义多个，按照定义的先后顺序执行

#### document.DOMContentLoaded窗口加载事件 *

**DOM加载完毕**(不包括标签里的内容、`CSS`样式等)后执行,即只加载标签名

> **注意**
>
> 对于标签里的属性会被加载，其值加不加载取决于是否是外部样式表、外部脚本、额外网络请求的资源以及外部资源

**以这个例子为例**
`<img src="../sources/img/c1.png" alt="" draggable="false">`

> 使用`document.DOMContentLoaded`事件
>
> `DOM`加载的内容为：`<img src="" alt="" draggable="false">`

- 语法：`window.addEventListener('DOMContentLoaded',function(){});`

#### window.onresize调整窗口大小事件

调整窗口大小时触发事件

> 传统方式：`window.onresize=function(){};`
>
> 事件监听：`window.addEventListener('resize',function(){});`

#### 定时器方法

##### 定时器之`setTimeout()`

`JavaScript` **提供定时执行代码**的功能，叫做定时器（`timer`），主要由`setTimeout()`和`setInterval()`这两个函数来完成。它们向任务队列添加定时任务

`setTimeout`函数用来指定某个函数或某段代码，在多少毫秒之后执行。它**返回一个整数，表示定时器的编号，以后可以用来取消这个定时器**。

>只**执行一次**

```js
var timerId = setTimeout(func|code, delay);
```

`setTimeout`函数接受**两个参数**，**第一个参数**`func|code`是将要推迟执行的**函数名或者一段代码**，**第二个参数**`delay`是**推迟执行的毫秒数**

```js
setTimeout(function(){
    console.log("定时器")
},1000)
```

> **温馨提示**
>
> 还有一个需要注意的地方，如果回调函数是对象的方法，那么`setTimeout`使得方法**内部的**`this`**关键字指向全局环境，而不是定义时所在的那个对象**

```js
var name = "sxt";
var user = {
    name: "itbaizhan",
    getName: function () {
        setTimeout(function(){
            console.log(this.name);//sxt
        },1000)
    }
};
user.getName();
```

解决方案

```js
var name = "sxt";
var user = {
    name: "itbaizhan",
    getName: function () {
        var that = this;//放在setTimeout前
        setTimeout(function(){
            console.log(that.name);//itbaizhan
        },1000)
    }
};
user.getName();
```

定时器可以进行取消

```js
var id = setTimeout(f, 1000);
clearTimeout(id);
```

> `setTimeout`可以有多个

```js
let oneSec = setTimeout(……)
let twoSec = setTimeout(……) // 不执行
let threeSec = setTimeout(……)

clearTimeout(twoSec)
```

##### 定时器之`setInterval()`

`setInterval`函数的用法与`setTimeout`完全一致，区别仅仅在于`setInterval`指定某个任务每隔一段时间就执行一次，也就是**无限次的定时执行**

```js
var timer = setInterval(function() {
  console.log(2);
}, 1000)
```

通过setInterval方法**实现网页动画**

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		#someDiv{
			width: 100px;
			height: 100px;
			background: red;
		}
	</style>
</head>
<body>
	<div id="someDiv"></div>
	<script>
		var div = document.getElementById('someDiv');
		var opacity = 1;
		var fader = setInterval(function() {
		  opacity -= 0.05;
		  if (opacity > 0) {
		    div.style.opacity = opacity;
		  } else {
		    clearInterval(fader);
		  }
		}, 30);

	</script>
</body>
</html>
```

定时器可以进行取消

```js
var id = setInterval(f, 1000);
clearInterval(id);
```

> **注意**
>
> `setInterval`、`setTimeout`是定时事件触发函数，实质是放到JS引擎队列中，执行队列中的代码才开始计时

```js
setTimeout(function(){
    alert("Hello");
},0)
alert("world"); // 先输出
```

> 在一个事件的响应代码执行完成之后，即使有待执行代码，浏览器也会执行**页面渲染和响应事件**(优先级高)
>
> 完成之后再执行队列中的代码

**证明：定时事件触发函数并非多线程**
```js
setTimeout(function(){
    while(true){}
},0)
setTimeout(function(){
    alert("foo")
},1000)
```

> 结果：页面直接卡死

#### location对象

描述`Internet`上某个页面的URL

`console.log(location.href); // 输出：http://127.0.0.1:5500/index.html`

`console.log(location.protocol); // 输出：http:`

##### URL

> 以`http://www.example.com:80/web/index.html?a=3&b=4`为例

#### window.getComputedStyle()方法

- **获取**指定元素的**css样式**

- 语法:`window.getComputedStyle(element,pseudoElement)`

```html
<body>
    <button onclick="myFunction()">点我获取背景颜色的值</button>
    <p style="background-color: rgb(178, 116, 230); height: 100px;" id="test">我是背景颜色</p>
    <p>p标签背景颜色的值为:<span></span></p>
    <script>
        function myFunction() {
            var p=document.getElementById('test')
            // console.log(p);

            // getPropertyValue()方法:返回指定的css属性的值
            var test=window.getComputedStyle(p).getPropertyValue('background-color');//获取到的是一个字符串类型的值，仅在ie9以上支持，
            // console.log(test);
            //获取的是`test`选择器所在的标签的所有css样式
            var test02=window.getComputedStyle(p);
            // console.log(test02);

            var span=document.querySelector(`p span`);
            span.innerHTML=test;
        }
    </script>
</body>
```

- 与element.style的区别
    1. `element.style`只能读取内联样式
    2. `getComputedStyle`能读取所有的样式
    3. `element.style`支持读写
    4. `getComputedStyle`只读

#### window.requestAnimationFrame()方法

- 作用：告诉浏览器要执行一个动画，请求浏览器在下一个重绘之前调用指定的函数更新动画

- 相比`setTimeout()`与`setInterval()`的优势
1. 性能：背后优化，若标签页或窗口不是激活状态，浏览器会减少或停止动画/绘制的帧率
2. 平滑：与显示屏刷新率同步
3. 节能：标签页隐藏或最小化时不运行，提高性能和省电

```js
function draw() {
    if (!video.paused && !video.ended) {
        // 清除旧帧
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 绘制新帧
        ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, canvas.width, canvasheight);
        // 请求下一帧,需要传递一个回调函数的参数地址draw，
        requestAnimationFrame(draw);
    }
}
draw();
```

## '多线程'

### Javascript执行机制

> **在浏览器中**，`JS`是单线程编程

- 异步`Ajax`：常用开发实践：发起异步`Ajax`，界面显示进度条样式

#### callBack hell 回调地狱

> 嵌套过多的回调函数 所导致的现象

```js
doSomething(function(result) {
    doSomethingElse(result, function(newResult) {
        doAnotherThing(newResult, function(finalResult) {
        }, function(error) {
            console.error(error);
        });
    }, function(error) {
        console.error(error);
    });
}, function(error) {
    console.error(error);
});
```

#### promise

`promise`是一个容器，它代表一个异步操作的**最终状态**（完成或失败）

> 解决   `callBack hell` 回调地狱    的问题

##### promise特点

- 应用：发送请求的一瞬间，后端尚未反馈的过程

- 状态
1. `pending`:进行
2. `fulfilled`:已成功
3. `rejected`:已失败

> **注意**
>
> 不受外界影响，由后端来改变状态、异步操作来改变
>
> 状态只能改变一次(例如：进行→已成功=>状态不能再变)

##### Promise基本用法

`ES6`规定，**`Promise`对象是一个构造函数**，用来生成`promise`实例

```html
<body>
    <script>
        // 创建Promise实例，自动提供一个执行器函数作为它的参数，执行器函数接收resolve、reject函数参数
        const p = new Promise((resolve, reject) => {
            // 模拟异步操作
            setTimeout(() => {
                const isSuccessful = true; // 假设这是我们的异步操作的结果
                if (isSuccessful) {
                    resolve("Operation was successful."); // 网页输出结果：Operation was successful.
                } else {
                    reject("Operation failed.");
                }
            }, 1000);
        });

        /* 处理Promise的结果 */
        p.then(result => {
            console.log(result); // 如果成功，打印结果
        }).catch(error => {
            console.error(error); // 如果失败，打印错误
        });
    </script>
</body>
```

> `resolve`和`reject`都是`Promise`接收的两个函数参数，并非自定义函数
>
> `then`、`catch`都可以处理`Promise`的成功和失败，分别使用这两个来处理成功和失败只是为了代码的清晰性和可读性

```html
<body>
    <script>
        let result = false;
        let p = new Promise(function (resolve, reject) {
            if (result) {
                resolve("data");
            } else {
                // new Erro("404"):创建一个新的错误对象，并赋予描述信息
                reject(new Error("404"))
            }
        });

        p.then(function () {
            console.log("success");
        })
            .catch(function (e) {
                // console.log("error"); // error
                console.log(e); // Error:404
            })
    </script>
</body>
```

##### 异步顺序

```html
<body>
    <script>
        let p = new Promise(function (resolve, reject) {
            console.log('Promise 1');
            resolve();
        });
        p.then(function () {
            console.log('resolved 2');
        })
        console.log('log 3');

        /**
         * 输出结果
         * Promise 1
         * log 3
         * resolved 2
        */
    </script>
</body>
```

```html
<body>
    <script>
        let p = new Promise(function (resolve, reject) {
            setTimeout(function () {
                console.log('setTimeout 4');
            },1000)
            console.log('Promise 1');
            resolve();
        });
        p.then(function () {
            console.log('resolved 2');
        })
        console.log('log 3');

        /**
         * 输出结果
         * Promise 1
         * log 3
         * resolved 2
         * setTimeout 4
        */
    </script>
</body>
```

```html
<body>
    <script>
        let p = new Promise(function (resolve, reject) {
            setTimeout(function () {
                console.log('setTimeout 4');
                resolve();
            },1000)
            console.log('Promise 1');
            // resolve();
        });
        p.then(function () {
            console.log('resolved 2');
        })
        console.log('log 3');

        /**
         * 输出结果
         * Promise 1
         * log 3
         * setTimeout 4
         * resolved 2
        */
    </script>
</body>
```

```html
<body>
    <script>
        const p1 = new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error('fail'))
            }, 3000)
        })

        const p2 = new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(p1)
            }, 1000)
        })

        p2.then(function (value) {
            console.log('success', value);
        })
            .catch(function (e) {
                console.log('error', e);
            })
    </script>
</body>
```

> 在`p2`中，`resolve`方法返回`p1`，即`p2`返回另一个`Promise`，导致`p2`自己的状态无效，`p1`的状态决定`p2`的状态
> 
> `p2`是`1s`后执行，此时`p1`还没到`3s`，所以`p2`返回了`error`，并且说明此时的状态的`pending`，然后等到`3s`以后，执行`Error:fail`
> 
> **注意**
>
> 调用`resolve`或`reject`并不会终结`Promise`的参数函数的执行，

```html
<body>
    <script>
        const p = new Promise(function (resolve, reject) {
            console.log("p");
            resolve();
        })

        p.then(function (result) {
            let p2 = new Promise(function (resolve, reject) {
                console.log("p2");
                resolve();
            });
            return p2;
        })
            .then(function (result) {
                let p3 = new Promise(function (resolve, reject) {
                    console.log("P3");
                    resolve();
                });
                return p3;
            })
            .catch(function () {
                console.log(error);
            })
    </script>
</body>
```

##### then链式例子

```html
<body>
    <p>
        <span id="num1"></span>
        <b>+</b>
        <span id="num2"></span></p>
    <input type="text">
    <script>
        let num1_value = Math.floor(Math.random() * 11);
        let num2_value = Math.floor(Math.random() * 11);
        let num1 = document.querySelector('#num1');
        let num2 = document.querySelector('#num2');
        let input = document.querySelector('input')

        num1.innerText = num1_value
        num2.innerText = num2_value

        let p1 = new Promise(function (resolve, reject) {
            num1_value = Math.floor(Math.random() * 11);
            num2_value = Math.floor(Math.random() * 11);
            num1.innerText = num1_value
            num2.innerText = num2_value
            setTimeout(function () {
                if (input.value == num1_value + num2_value) {
                    resolve('第一题正确')
                }
                else {
                    reject('错误答案')
                }
            }, 3000)
        })

        p1
            .then(function (value) {
                console.log(value);
                let p2 = new Promise(function (resolve, reject) {
                    num1_value = Math.floor(Math.random() * 11);
                    num2_value = Math.floor(Math.random() * 11);
                    num1.innerText = num1_value
                    num2.innerText = num2_value
                    setTimeout(function () {
                        if (input.value == num1_value + num2_value) {
                            resolve('小天才')
                        }
                        else {
                            reject('错误答案')
                        }
                    }, 3000)
                })
                return p2;
            })
        // 返回了p2，相当于返回了一个Promise的实例对象，因此可以继续使用then，达到了链式效果
            .then(function (value) {
                console.log(value);
                let p3 = new Promise(function (resolve, reject) {
                    num1_value = Math.floor(Math.random() * 11);
                    num2_value = Math.floor(Math.random() * 11);
                    num1.innerText = num1_value
                    num2.innerText = num2_value
                    setTimeout(function () {
                        if (input.value == num1_value + num2_value) {
                            resolve('kami')
                        }
                        else {
                            reject('错误答案')
                        }
                    }, 3000)
                })
                return p3;
            })
            .then(function (value) {
                console.log(value);
            })
            .catch(function (e) {
                console.log(e);
            })

    </script>
</body>
```

##### Promise.resolve()

- 作用
1. 将`Promise`对象转换成成功，返回一个实例，可直接运行`then()`
2. 将非`Promise`对象 => `Promise`对象

##### Promise.all()

- 作用
1. 将多个`Promise`实例包装成一个新的`Promise`实例，接受一个数组作为参数
2. 将分散的`Promise`整合成一个`Promise`

```html
<body>
    <script>
        const p1 = new Promise(function (resolve, reject) {
            resolve('p1 success');
        })
        const p2 = new Promise(function (resolve, reject) {
            resolve('p2 success');
        })

        Promise.all([p1, p2]).then(function (result) { console.log(result); })
            .catch(function (e) { console.log(e) })

        /**
         * 输出结果
         * Array [ "p1 success", "p2 success" ]
        */
    </script>
</body>
```

```js
const p1 = new Promise(function (resolve, reject) {
    resolve('p1 success');
})

const p2 = new Promise(function (resolve, reject) {
    reject('p2 fail');
})

Promise.all([p1, p2]).then(function (result) { console.log(result); })
    .catch(function (e) { console.log(e) })
```

> 只要数组中的`Promise`实例中有一个被拒绝，将会调用`catch`方法

```html
<body>
    <script>
        const p1 = new Promise(function (resolve, reject) {
            resolve('p1 success');
        })
        const p2 = new Promise(function (resolve, reject) {
            reject('p2 fail');
        })
            .catch(function (result) {
                return result
            })
            .then(function (e) {
                return e
            })
		// p2失败后运行catch，最后return给了p2，p2得到了字符串结果，由于Promise.resolve()特性(在Promise.all里是成功的，所以是Promise，resolve())自动变成Promise实例
        Promise.all([p1, p2]).then(function (result) { console.log(result); })
            .catch(function (e) { console.log(e) })

        /**
         * 输出结果
         * Array [ "p1 success", "p2 fail" ]
        */
    </script>
</body>
```

> 这里能够全部被成功解决是因为，`p2`被拒绝以后调用`catch`方法，此时结束，整个`p2`被当作了成功解决

# ECMAScript6

## 数组的解构赋值(destructuring)

从数组和对象中提取值，对变量进行赋值

```js
// 老版本
let a=1;
let b=2;
let c=3;

// 新版本
let [a,b,c]=[1,2,3];
console.log(a,b,c);
```

## Template string 模板字符串(`)

## 函数默认参数

## rest参数

- 作用：接收多余的实参，放入数组中(类似于扩展运算符)

> 与`arguments`：存放多个形参(即接收所有实参)，返回伪数组(不能用数组的方法),函数创建时提供的

```js
function f(x,y,...values){
    console.log(arguments); // [1,2,3,4]
    console.log(values); // [3,4]
}
f(1,2,3,4)
```

## 箭头函数 *

语法:`(参数1,参数2,……,参数N) => { 函数声明 }`

`(参数1,参数2,……,参数N) => 表达式(单一)`

`(单一参数) => {函数声明}`

`单一参数 => {函数声明}`

`() => {函数声明}`

```js
var x=(function(){
    return 2
})()

console.log(x);

const y=(()=>x+1)()
console.log(y);

var z=(()=>{return x+y})()

console.log(z);
```

>**注意**
>
>使用箭头函数，默认**绑定外层`this`**的值，在箭头函数表达式中`this`的值和外层的`this`是一样的
>
>使用const较安全，因为此时函数的表达式变成一个常量，它不再能重新调用这个函数去赋值

```js
var obj={
    i:10,
    b:function(){
        // 箭头函数 没有自己的this，即箭头函数不会创建自己的this，继承自己作用域链的上一层的this
        return() => {
            console.log(this.i,this);
        }
    },
    c:function(){
        console.log(this.i,this)
    }
}
obj.b()(); // 10,Object(……)
obj.c(); // 10,Object(……)
```



```js
function(x){return x;}
// 转换
x=>x
```

## this指向问题

- 全局作用域/普通函数/定时器 => `this`指向全局对象`window`

```js
console.log(this); // this指向window
function fn(){
    console.log(this);
}
window.fn(); // this指向的是window
```

- 在方法中，**谁调用的方法，this指向谁**

```js
var o={
    sayHi:function(){
        console.log(this);
    }
};
o.sayHi(); // sayHi中的this指向的是o对象
```

> **注意**
>
> 在严格模式下，没有设置`this`的值，会保持`undefined`

```js
function f2(){
    "use strict"; // 使用严格模式下编写
    return this;
}
f2()===undefined; // true
```



- 构造函数 => **this指向谁建的实例**

```js
function Fun(){
    console.log(this);
}
var fun=new Fun(); // Fun中的this指向实例fun
```

> 方法和函数的区别



**思考**

```js
var A = {
    name:"张三",
    f:function(){
        console.log("姓名:"+this.name);
    }
}

var B={
    name:'李四'
};

B.f=A.f
B.f() // 李四
A.f() // 张三
```

**事件中的this**

```html
<button onclick="clickMe()">
    btn
</button>
<script>
    function clickMe(){
        console.log(this); // window
    }
</script>
```

## call()方法和apply()方法

## bind()方法

`bind`，浅拷贝的形式(创建一个新的函数)，自定义`this`指向

```js
const obj = {
    x:11,
    getX:function(){
        return this;
    }
};
const unbound = obj.getX;
console.log(unbound()); // window
const bound = unbound.bind();
console.log(bound()); // obj
```

## Symbol(符号)

- 符号的基本用法

```js
let sym=Symbol();
console.log(typeof sym); // symbol
```

> 符号本身是原始数据类型，需要使用`Symbol()`函数初始化

`Symbol()`函数不能与`new`关键字一起作为构建函数使用，为了避免创建符号(`Symbol`)包装对象(`object`)

---

什么是符号包装对象？

将符号包装为对象的过程，并提供一些方法和属性来操作它

---

为什么要避免创建符号包装对象

保证唯一性，不能修改

---

```html
<body>
    <script>
        let symbol = Symbol();
        let sym = Object(symbol);
        console.log(typeof sym); // object
    </script>
</body>
```

> 确实想用符号包装对象，使用`Object()`函数

- 使用符号作为属性

## `Class`类

类是**面向对象**的基础，是用户定义的**引用数据类型**，称为**类类型**，它是特殊的"函数"，概括相同特征、食物，**类的实例称为对象**

> 类的存在是为了简洁、提高代码效率

### `Class`类声明

```js
function f(){}
let f2=function(){}

class C{}
let c2=class{}
```

- 函数声明与类声明

函数声明会提升(即可以先使用再声明)，类声明不会

### `Class`类的实例

`new`修饰函数 => 构造函数

```JS
// 代替class的ES5写法
function f(){}
let f_obj = new f();
```

生成类的实例，需要使用`new`关键字

```js
class Test{
    constructor(){}
}
let test_obj=new Test()
```

### 构造函数与方法

```js
class Person{
    // constructor:相当于构造函数,有且仅有一个
    constructor(name,age){
        this.name = name;
        this.age = age;
    }

    sayHello(){
        console.log('Hello,my name is ${this.name} and I am ${this.age} years old');
    }
}

const person1 = new Person('Jack',20);
person1.sayHello(); // 输出：Hello,my name is Jack and I am 20 years old
```

### `static`方法及其`this`

静态方法不能被实例继承(即实例不能用)

```html
<body>
    <script>
        class Person {
            static sayHi() {
                console.log(this);
            }
            sayHi() {
                console.log(this);
            }
        }
        let zhangsan = new Person();

        Person.sayHi(); // Person这个对象
        zhangsan.sayHi(); // zhangsan这个实例对象
    </script>
</body>
```

### `Class`类继承

本质：子类的隐式原型 继承 父类的隐式原型

```js
class Person{
    constructor(name){
        this.name=name;
    }
}
class Students extends Person{
    constructor(name,id){
        super(name); // 用来调用父类，必须放在开头
        this.id=id;
    }
}
let zhangsan = new Students("zhangsan",123);
console.log(zhangsan); // zhangsan这个实例对象
```

### 原型链 *

```js
/* ES5原型链继承写法 */
function Person(name){
    this.name=name;
}
function Students(name,id){
    Person.call(this.name); // 改变this指向，将Person的name给Students
    this.id=id;
}
Students.prototype.__proto__=Person.prototype;

// 所有方法都在prototype里，所以添加方法也是这样
Person.prototype.showName=function(){
    return this.name;
}
Students.prototype.showID=function(){
    return this.id;
}
let zhangsan = new Students("zhangsan",123);
console.log(zhangsan);
```

- ES5类的写法，通常函数名以大写开头，区分普通函数
- 通过this来表示对象属性，通过prototype来添加对象方法

## `async`异步

本质上，返回一个`Promise`对象，遇到`await`会先返回

```js
function after3Seconds(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve('resolved after 3 Seconds');
        },2000)
    });
}
function after1Seconds(){
    return new Promise(resolve=>{
        setTimeout(()=>{
            resolve('resolved after 1 Seconds');
        },1000)
    });
}
async function asyncCall(){
    console.log('start');
    /* const r1 = await after3Seconds();
    console.log(r1);
    const r2 = await after1Seconds();
    console.log(r2) */
    
    // 第二种
    let r = await Promise.all([after3Seconds(),after1Seconds()]);
    console.log(r);
    /*
    * start
    * ['resolved after 3 Seconds','resolved after 1 Seconds']
    */
}

asyncCall()
.catch(error => {
    console.log(error);
});

/*
* start
* resolved after 3 Seconds
* resolved after 1 Seconds
*/
```

# CSS操作

## `HTML` 元素的 `style` 属性

**获取**或设置元素的`style`样式属性

`setAttribute`方法直接操作网页元素的`style`属性

```js
div.setAttribute(
  'style',
  'background-color:red;' + 'border:1px solid black;'
);
```

`getAttribute()`:获取元素指定属性的值

`removeAttribute()`:为元素删除指定的属性

- 点击一次后不能再点击
```js
function start() {
    firing.setAttribute(
        'style',
        'display:none;'
    );
    video.play();
    drawVideoTocanvas(video, canvas)
    canvas.removeEventListener('click', start);
}
canvas.addEventListener('click', start)
```

## 元素节点的`style`属性

```js
var divStyle = document.querySelector('div').style;

divStyle.backgroundColor = 'red';
divStyle.border = '1px solid black';
divStyle.width = '100px';
divStyle.height = '100px';
divStyle.fontSize = '10em';
```

## `cssText`属性

```js
var divStyle = document.querySelector('div').style;

divStyle.cssText = 'background-color: red;'
  + 'border: 1px solid black;'
  + 'height: 100px;'
  + 'width: 100px;';
```

# 事件类型之键盘事件

1. keydown：按下键盘时触发。
2. keypress：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时**先触发keydown事件，再触发这个事件。**
3. keyup：松开键盘时触发该事件

```js
username.onkeypress = function(e){
    console.log("keypress事件");
}
```

**禁用F12的使用**
```js
document.onkeydown = function () {
    if (window.event && window.event.keyCode == 123) {
        event.keyCode = 0;
        event.returnValue = false;
    }
}
```

## event对象

keyCode:唯一标识

```js
var username = document.getElementById("username");
//非DOM2级，都要`on``前缀
username.onkeydown = function(e){
    if(e.keyCode === 13){
        console.log("回车");
    }
}
```


# 事件类型之表单事件



表单事件是在**使用表单元素及输入框元素**可以监听的一系列事件

1. input事件
2. select事件
3. Change事件：失去焦点且内容发生**改变**
4. reset事件：重置
5. submit事件：提交
6. onblur事件：失去焦点
7. onfoces事件:获得焦点时触发



## input事件

input事件当使用`<input>、<select>、<textarea>`标签是触发，例如`p`就不行。

input事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次input事件。

```js
var username = document.getElementById("username");
username.oninput = function(e){
    console.log(e.target.value);
}
```



## select事件

select事件当使用`<input>、<textarea>`时，并且选中全部文本时触发

```js
// HTML 代码如下
// <input id="test" type="text" value="Select me!" />

var elem = document.getElementById('test');
elem.addEventListener('select', function (e) {
  console.log(e.type); // "select"
}, false);
```



## Change 事件

Change事件使用`<input>、<select>、<textarea>`时触发。只有当全部修改完成时才会触发

```js
var email = document.getElementById("email");
email.onchange = function(e){
    console.log(e.target.value);
}
```



## reset 事件，submit 事件

这两个事件发**生在表单对象`<form>`上**，而不是发生在表单的成员上。

reset事件当表单重置（所有表单成员变回默认值）时触发。

submit事件当表单数据向服务器提交时触发。注意，submit事件的发生对象是`<form>`元素，而不是`<button>`元素，因为提交的是表单，而不是按钮

```html
<form id="myForm" onsubmit="submitHandle">
    <button onclick="resetHandle">重置数据</button>
    <button>提交</button>
</form>
```

```js
var myForm = document.getElementById("myForm")
function resetHandle(){
    myForm.reset();
}
function submitHandle(){
    console.log("提交");
}
```

# 事件类型之页面事件

1. load:页面加载完成时触发
2. unload：页面卸载时触发

# 防抖和节流

> 防抖与节流，

    作用于-在进行窗口的resize（调整大小）、scroll，输入框内容校验等操作
    作用于-用户在登陆的时候点提交时，出现服务器多次请求的情况


>**理解**~以moba游戏为例
>
>节流：连续使用技能，在技能cd完之前，施放的技能无效
>
>防抖：连续触发回城，每次触发都会重新计时（重新读条），直到回城倒计时结束，才能真正执行回城

## 防抖(debounce)

防抖严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死。

从滚动条监听的例子说起

```js
function showTop  () {
    var scrollTop = document.documentElement.scrollTop;
    console.log('滚动条位置：' + scrollTop);
}
// window.onscroll:顶部移动的过程中触发
// 缺陷，每次移动都发现函数执行了几次
window.onscroll  = showTop//不用括号，使用的时候会调用；用括号就只会调用1次
```

在运行的时候会发现存在一个问题：这个函数的默认执行频率，太！高！了！。 高到什么程度呢？以chrome为例，我们可以点击选中一个页面的滚动条，然后点击一次键盘的【向下方向键】，会发现函数执行了8-9次！



然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里，所以接着讨论如何优化这种场景。

基于上述场景，首先提出第一种思路：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后

1. 如果在200ms内没有再次触发滚动事件，那么就执行函数
2. 如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时

效果：如果短时间内大量触发同一事件，只会执行一次函数


>**原理**
>
>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会触发handle函数。
>
>**实现代码过程理解**
>
>在你输入的时候，每次输入都会调用函数，你的函数第一个语句就是清除时间函数，所以在你输入过程中不会执行。当你停下来的时候，它就执行，清除以后执行定时器，当你超过那个时间就会输出；所以防抖就是你最后一次输入完，并且 超过那个延时才会输出
>
>这就与不用防抖就会执行多次，因为它没有输入时的清除的效果
>
>**那又为什么会调用7-8次呢**
>
>这个或许就是你按下来到放某个按键时，“那是一段时间”


实现：既然前面都提到了计时，那实现的关键就在于setTimeout这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现

```js
function debounce(fn,delay){
    //只运行一次，因为let不能重复定义
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.documentElement.scrollTop;
    console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop,300)
```

**let 和 var 的区别**
1. `var`相当于全局变量，`let`相当于局部变量
2. `let`和int这些差不多，`var`可以先使用再声明
3. `let`不能重定义，`var`可以

> **防抖定义**
>
> 对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次

## 节流(throttle)

节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死

继续思考，使用上面的防抖方案来处理问题的结果是

如果在限定时间段内，不断触发滚动事件（比如某个用户闲着无聊，按住滚动不断的拖来拖去），只要不停止触发，理论上就永远不会输出当前距离顶部的距离

但是如果产品同学的期望处理方案是：即使用户不断拖动滚动条，也能在某个时间间隔之后给出反馈呢？

其实很简单：我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）

效果：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效

**实现**

这里借助setTimeout来做一个简单的实现，加上一个状态位valid来表示当前函数是否处于工作状态

```js
function throttle(fn,delay){
    let valid = true
    return function() {
        //可能为true，可能为false
       if(!valid){// valid==false时运行
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false//存在是为了让它有间隔期
        setTimeout(function(){
            fn()
            valid = true;
        }, delay)
    }
}

/*
  throttle函数的执行过程理解：
    首先let只能定义一次，无法重复定义，该语句从头到尾就只有开始进行
    一开始valid定义为true，if语句不运行，则不休息，开始走下面的语句，
    此时valid又被赋值了为false，接下来setTimeout函数会被运行，
    在过了delay延迟时间后开始执行fn函数并且valid被赋值为true，
    在延迟时间的过程中，valid一直保持着false的状态，那个if语句就会持续进行，
    直到延迟时间到了后输出一次并且valid为true，又开始第二次的不休息，
    这就导致了它会在你输入的过程中，函数会一直运行调用，但是valid这个全局变量的原因，
    在它延时结束以后不会变成true，就会走if语句，因此，
    它不会一直输出也不会输入完毕以后在输出，而是循环一定的时间输出
*/

function showTop  () {
    var scrollTop = document.documentElement.scrollTop;
    console.log('滚动条位置：' + scrollTop);
}
window.onscroll = throttle(showTop,300) 
```



如果一直拖着滚动条进行滚动，那么会以300ms的时间间隔，持续输出当前位置和顶部的距离

讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景:

1. 搜索框input事件，例如要支持输入**实时搜索可以使用节流方案**（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求

2. 页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）

# 回调函数

- 定义

>**函数A作为参数**传递给B，在B内调用A，称A为回调函数

- 作用：异步、域、跨列

> 异步：单线程，部分操作需要花很长时间(网络请求、文件读取、定时器、`Promise`等)，防止因为这些操作阻塞主线程
>
> 域：即闭包
>
> 跨域：从不同域中获取数据或调用功能，例如：JSONP、CORS等，用作处理返回的数据或响应的回调函数

**基本用法**
```js
let sum;
// 相当于切菜
function fnA(num1,num2,fn){
    return fn(num1,num2)
}

// 相当于做菜
function fnB(num1,num2){
    return num1+num2
}

sum=fnA(1,2,fnB) // 传递fnB地址
console.log(sum) // 3
```

# Map对象

`Map`是`JavaScript`的一种数据结构，用于存储键值对的集合

- 对比普通对象的优势
1. 默认情况下，不包含任何键，只包含显式插入的键(普通对象在设置键的时候可能与原有的键冲突)
2. 通过`size`获取键值对的个数(普通对象只能手动计算)

- 应用
1. 存储键值对：键和值可以自定义类型的数据

## new Map()

```js
const map=new Map();

map.set('name','Jack');
map.set('age',20);

console.log(map.size); // 输出：2
console.log(map.get('name')); // 输出：Jack
console.log(map.has('name')); // 输出：true

map.delete('name');
console.log(map.has('name')); // 输出：false
console.log(map.size); // 输出：1
```

```js
// 还可以通过函数形式去设置键值对
class Entity{
    constructor(name,age){
        this._compMap=new Map();
    }

    addComp(comp){
        // 设置了一个*.name属性，其值为*
        this._compMap.set(comp.name,comp);
    }

    getComp(comp){
        return this._compMap.get(comp);
    }
}
```

**数组传递方式**
```html
<script>
    const pairs = new Map([
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    console.log(pairs.has('{')); // false
    console.log(pairs.has('}')); // true

    console.log(pairs.get(']')); // '['
</script>
```

## get()方法

- 作用：返回指定**键的值**

- 语法：`mapObj.get(key)`

```html
<script>
var map=new Map();
map.set(1,"jQuery");
map.set(2,"AngularJS");
map.set(3,"Bootstrap");

document.writeln(map.get(1)+"<br>"); // jQuery
document.writeln(map.get(2)+"<br>"); // AngularJS
document.writeln(map.get(3)+"<br>"); // Bootstrap

document.writeln(map.get(5)); // undefined
</script>
```

## has()方法

- 作用：判断`Map`对象是否存在指定的键

- 语法：`myMap.has(key);`

```html
<script>
    var test = new Map();
    test.set('t',1);
    console.log(test.has('t')); // true
    console.log(test.has(1)); // false
</script>
```

## map接口数据映射(循环遍历第一种方法)

```js
let gifts=[1,2,3,4]

gifts.map(item=>{
    console.log(item); // 1 2 3 4
});
```

## 遍历

```js
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

map.forEach((value, key) => {
  console.log(key, value);
});
```

- 注意，上面的方法如果在函数里面使用了forEach，并且在forEach里return是不会终止函数的，因为forEach里面本身就是一个回调函数，return只是结束当前的回调函数而已

- 使用 forEach，第一个参数是 map 的值，第二个参数是 map 的key

- 错误示范

- ```js
  Trie.prototype.startsWith = function (prefix) {
      this.map.forEach((value, key) => {
          // 判断是否有元素包含prefix
          for (let i = 0, j = prefix.length;
              i < key.length;
              i++, j++) {
              if (prefix == key.substring(i, j)) return true
          }
      })
      return false
  };
  ```

- 只遍历keys

- ```ja
  Trie.prototype.startsWith = function (prefix) {
      for (let word of this.map.keys()) {
          if (word.substring(0, prefix.length) === prefix) {
              return true;
          }
      }
      return false;
  };
  ```

## 实际应用

**罗马数字转整数**
```js
var romanToInt=function(s){
    const rome=new Map();
    rome.set('I',1);
    rome.set('V',5);
    rome.set('X',10);
    rome.set('L',50);
    rome.set('C',100);
    rome.set('D',500);
    rome.set('M',1000);
    var sSum=0;
    for(let i=0;i<s.length;i++){
        if(i+1<s.length&&rome.get(s[i])<rome.get(s[i+1])) sSum-=rome.get(s[i]);
        else sSum+=rome.get(s[i];)
    }
    return sSum;
};
```

# 标准内置对象

## set

### 描述

> 值的集合，集合中的值**只能出现一次**
>
> **注意**：主要目的是处理唯一值，而不是键值对

- Set对象只接受一个参数
- 数组去重：const arr = new Set(nums);

### 实例属性 *

- `size`：集合中元素的数量

```html
<body>
    <script>
        let test = new Set([
            [1, 2],
            [3, 4],
            [5, 6],
            [5, 6]
        ]);
        console.log(test.size); // 4
    </script>
</body>
```

> 此时返回`4`的原因是因为数组是对象引用，尽管内容相同，但内存中的地址不一样

### 实例方法 *

- `add(value)`：若`Set`中不存在相同的值，则插入到对象中

```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(1)
        test.add(2)
        console.log(test.size); // 2
    </script>
</body>
```

- `clear()`:删除对象中的所有元素

```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(1)
        test.add(2)

        test.clear()
        console.log(test.size); // 0
    </script>
</body>
```

- `delete(value)`:删除对象中指定的元素,并返回一个布尔值

```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(2)

        console.log(test.delete(1)); // true
        console.log(test.delete(1)); // false
    </script>
</body>
```

- `forEach()`:按插入顺序对对象中每个值都调用该函数，如果提供了参数，这个参数作为函数的参数

```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(2)
        test.add(3)
        test.add(4)
        let i=0;

        test.forEach(function(){
            console.log('test'+i);
            i++;
        },i)
        // 输出：
        // test0
        // test1
        // test2
        // test3
    </script>
</body>
```

- `has()`：判断是否存在给定值的元素，返回一个布尔值
  
```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(2)
        test.add(3)
        test.add(4)
        
        console.log(test.has(4)); // true
        console.log(test.has(5)); // false
    </script>
</body>
```

- `keys`/`values`：用于迭代，返回一个**新的**可迭代迭代器对象

```html
<body>
    <script>
        let test = new Set();
        test.add(1)
        test.add(2)
        test.add(3)
        test.add(4)
        
        test_obj=test.keys();
        console.log(test_obj.next().value); // 1
        console.log(test_obj.next().value); // 2
        console.log(test_obj.next().value); // 3
        console.log(test_obj.next().value); // 4

        // 能作为数组来遍历
        // 此处不会有任何输出，迭代器的特性会记录当前遍历的位置，前面已经遍历到末尾了，再继续往下遍历不会有输出
        // for (const it of test_obj) {
        //     console.log(it);
        // }

        // test.keys()是新建了一个迭代器，因此重新开始遍历
        for (const it of test.keys()) {
            console.log(it); // 1，2，3，4
        }
    </script>
</body>
```

# 语言基础

## 语句

### `break`和`continue`语句

- 与**标签语句**一起使用

```html
<body>
    <script>
        let num = 0;
        outermost:
        for (let i = 0; i < 10; i++) {
            // outermost: // 95 99
            for (let j = 0; j < 10; j++) {
                if (i == 5 && j == 5) {
                    // break outermost; // 55
                    continue outermost; // 95
                }
                num++;
            }
        }
        console.log(num);
    </script>
</body>
```

>  添加标签语句，可以指定跳出循环层

### `with`语句

- 作用

1. 将代码作用域设定为**特定的对象**
2. 简化对一个对象反复操作

# `JavaScript Array`对象

## `JavaScript Array filter()`方法 *

- 作用：创建一个新的数组，新数组中的元素是指定数组中符合条件的元素

# `JavaScript`字符串

## 字符串方法

- `localeCompare()`：比较两个字符串，根据**本地排序规则**

在比较时间字符串时，会自动按照时间的先后顺序进行正确的比较，而不受到字符串转数字的影响

# 解构赋值

## 对象模型的解构

- 作用：从对象中提取值并赋值给变量
- 语法：`const { 属性名1,属性名2,…… } = 对象`

运行机制：创建一个新的变量，存储从对象中提取的属性值，将对象中对应属性名的属性值赋值给新变量，没有则赋值为undefined


# 实战

## clientX事件属性

### 定义和用法

返回鼠标指针相对于浏览器页面（左侧）的水平坐标

### 语法

`event.clientX`,event是变量名
```js
var left=event.clientX
```

## getBoundingClientRect()方法

用于获取某个元素距离浏览器的位置，集合中有top、right、left和bottom等属性

```js
smallPic.getBoundingClientRect().left
```

## 闭包函数

闭包就是一个函数引用另一个函数的变量，这样做的目的是为了**让变量被引用**着导致它**不能被回收**，用来封装一个私有变量。
即**子函数**可以**使用父函数的局部变量**、父函数的参数

```js
// 匿名函数自动调用表达式 (function(){})()
// 匿名函数自动调用表达式(箭头表达形式)  (()=>{})()
// 函数表达式后面紧跟()会自动调用
var a=(function () { // 变量a指向一个函数
        var count;
        return function () {
            return count+=1;
        }
    })(); // 函数自调，外面添加括号是为了说明它是一个函数表达式:指定是围起function这个函数的括号，这样才能调用，不然会报错。除了有变量去接收

    /*
        这个也是正确写法： 这里不添加括号，变量a不再指向一个函数，而是返回一个东西
        var a=function () {
        var count;
        return count+=1;
        
    }();
    */

    // 错误写法：
    /*
        function () { /*...*/
    /*    }()*/
    
a()
a()
a()
console.log(a());
```

变量 add 指定了函数自我调用的返回字值。

自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。

add变量可以作为一个函数使用。

这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。

count受匿名函数的作用域保护，只能通过 add 方法修改。

>**注意**
>
>不必要的闭包会导致内存的消耗
>
>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。
>
>直观的说就是**形成一个不销毁的栈环境**。

### 匿名函数

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="save">点击按钮</button>
    <script>
        onload=function(){
            alert('我在加载的时候就出来了');
        }
    </script>
</body>
</html>
<!-- 根据优先级关系，先弹窗在出现button，根据你js代码放的位置来决定 -->
<!-- <script>
    onload=function(){
        alert('我在加载的时候就出来了');
    }
</script> -->
```

## 插件

以`.min.js`结尾的为`js`的插件/组件

1. `zoomsl.min.js`:放大镜的插件

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="js/jquery-1.11.0.min.js" type="text/javascript"></script>
    <script src="js/zoomsl.min.js"></script>
</head>
<body>
    <script>
        jQuery(function() {
            // 初始化imagezoomsl方法/容器
            $('.demo').imagezoomsl({
                // 放大的范围，为宽高3：3(等比缩放)
                zoomrange:[3,3]
            })
        })
    </script>
    <img class="demo" src="./images/thumb.jpg" data-large="./images/big.jpg" title="">
</body>
</html>
```

>`$(需要引用的对象)`:引用对象去执行某些代码
>
>效果演示在当前目录下的`movie`文件夹里的**图片放大镜效果**

## Web

### 用户端动态脚本

#### 客户端Web API

##### 视频和音频API

**HTML5视频**
```html
<body>
    <video>
        <!-- source:用于让浏览器选择它所支持的源文件 -->
        <source src="./素材/Lost Princes.mp4" type="video/mp4">
        <source src="./素材/Lost Princes.webm" type="video/webm">
        <!-- 均不支持执行下面语句 -->
        <p>
            Your browser doesn't support HTML5 video. Here is a
            <a href="./素材/Lost Princes.mp4">link to the video</a>instead
        </p>
    </video>
</body>
```

- `HTMLMediaElement API`
1. `HTMLMediaElement.play()`：播放
2. `HTMLMediaElement.pause()`:暂停
3. `HTMLMediaElement.currentTime`:以秒为单位返回当前播放时间
4. `HTMLMediaElement.duration`:以秒为单位返回总时长

> **注意**
>
> 这里获取的是`video`标签或者`audio`标签

```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .player {
            width: 1200px;
        }
    </style>
</head>

<body>
    <div class="player">
        <video style="width: 100%;" controls>
            <!-- source:用于让浏览器选择它所支持的源文件 -->
            <source src="./素材/Lost Princes.mp4" type="video/mp4">
            <source src="./素材/Lost Princes.webm" type="video/webm">
            <!-- 均不支持执行下面语句 -->
            <p>
                Your browser doesn't support HTML5 video. Here is a
                <a href="./素材/Lost Princes.mp4">link to the video</a>instead
            </p>
        </video>
        <span>00:00</span>
    </div>
    <button>开始播放</button>
    <script>
        // 获取video元素
        var video = document.querySelector('video');
        var button = document.querySelector('button');
        // 获取span元素
        var span = document.querySelector('span');
        video.removeAttribute('controls');
        button.addEventListener('click', playerMovie);
        function playerMovie() {
            if (video.paused) {
                video.play()
            } else {
                video.pause();
            }
        }

        // var controlsTime;
        video.addEventListener('timeupdate', timerControls);
        function timerControls() {
            var minute = Math.floor(video.currentTime / 60);
            var second = Math.floor(video.currentTime - minute * 60);
            var minuteValue = minute < 10 ? '0' + minute : minute;
            var secondValue = second < 10 ? '0' + second : second;
            span.innerHTML = minuteValue + ':' + secondValue;
        }
    </script>
</body>
```

## `<video>`元素

- 常用属性
1. video.videoWidth：获取视频的实际宽度，并非是容器的宽度
2. video.videoHeight:获取视频的实际高度

```html
<body>
    <video src="./sources/movie/Lost Princes.mp4"></video>
    <script>
        var video = document.querySelector('video')

        // 浏览器开始解析和执行上面脚本时，尚未加载视频宽高
        // console.log(video.videoWidth); // 0
        // console.log(video.videoHeight); // 0

        // loadedmetadata：视频数据已加载时，触发事件
        video.addEventListener('loadedmetadata', function () {
            console.log(video.videoWidth); // 3840
            console.log(video.videoHeight); // 2160
        })
    </script>
</body>
```

## HTML对象

### 画布 (`canvas`)

#### clearRect()方法

- 作用：清除**2D上下文**画布上指定矩形区域的内容，使其完全透明

- 语法：`ctx.clearRect(x,y,width,height);`

- 参数
1. `x`：矩形左上角的x坐标
2. `y`：矩形左上角的y坐标
3. `width`：需要清除矩形的宽度
4. `height`：需要清除矩形的高度

```html
<body>
    <canvas id="myCanvas" width="300" height="150"></canvas>
    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx=canvas.getContext("2d");

        // 在画布上绘制一个红色的矩形
        ctx.fillStyle = "rgb(200,0,0)";
        ctx.fillRect(0,0,150,100)

        // 清除矩形的一部分
        ctx.clearRect(50,20,70,60)
    </script>
</body>
```

#### drawImage()方法

- 作用：在**2D渲染上下文**画布上绘制图像、视频帧或其他`<canvas>`元素的内容

- 语法(三个参数版本适应不同需求)
1. `ctx.drawImage(image,dx,dy);`
    1. `image`:图像、视频或另一个`<canvas>`元素
    2. `dx`和`dy`：在画布上的目标位置，定义图像左上角的坐标
2. `ctx.drawImage(image,dx,dy,dWidth,dHeight)`
   1. `dWidth`和`dHeight`：图像的**目标**宽度和高度，用于**缩放**
3. `ctx.drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)`
   1. `sx`和`sy`：源图像中矩形区域的左上角坐标
   2. `sWidth`和`sHeight`：源图像中选择的矩形宽度和高度
   3. `dx`、`dy`、`dWidth`和`dHeight`：在画布上的目标矩形

> **注意**
>
> 在使用此方法，一定要确保图像、视频已经加载完成(即你绘制的那一帧要加载完成)

#### beginPath()方法

- 作用
  - 路径开始的起点，或重置当前的路径(移动时，能够不保留之前的位置)；
  - 能够使用这些方法来创建路径：`moveTo()`、`lineTo()`、`quadricCurveTo()`、`bezierCurveTo()`、`arcTo()` 和 `arc()`

### 视频

#### 视频暂停属性(paused)

- 作用：表示视频当前是否处于暂停状态

1. `paused=true`:视频当前处于暂停状态
2. `paused=false`:视频当前正在播放

- 应用
1. 检查视频的播放状态
2. 切换视频的播放状态
3. 视频暂停时显示用户界面

#### 视频结束属性(ended)

- 作用：表示视频是否已经播放到结束

1. `ended=true`:视频已经播放结束
2. `ended=false`:视频尚未播放到结束或者尚未播放

- 应用：
1. 检查视频是否完成播放
2. 重置视频
3. 显示重播按钮
4. 加载其他内容

## JavaScript 对象

### JavaScript Array 对象

- JavaScript reduce()方法

应用场景：数组求和、数组求积、统计数组中元素出现的次数、数组去重等（循环遍历能做的都能做）

作用：对数组中每个元素执行reduce函数，将结果汇总后返回一个值

语法

```js
array.reduce((prev,cur,index,arr)=>{
    /***/
},initialValue)
```

参数：

prev：必须，上一次调用回调函数reduce所返回的值，一开始是初始值initialValue

cur：必须，数组中当前被处理的元素

index：当前元素的索引值

arr：调用reduce的数组

案例：数组求和

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let nums = [1, 7, 3, 6, 5, 6]
        // const total = nums.reduce((a, b) => a + b, 0)
        const total = nums.reduce((a, b) => {
            return a + b
        }, 0)
        console.log(total)
    </script>
</body>

</html>
```

## 算法

### 迭代

- 思想：不断的做同一件事情，有for循环（迭代思想）就有迭代

- 典型案例：反转链表

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    let pre = null
    // 注意，这里并不是赋值，而是链表指向的改变
    let cur = head
    while (cur) {
        const next = cur.next
        cur.next = pre
        pre = cur
        cur = next
    }
    return pre
};
```

---
二叉树的前序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
    let res = []
    let stack = []
    if (root == null) return res
    stack.push(root)
    while (stack.length != 0) {
        let temp = stack.pop()
        res.push(temp.val)
        if (temp.right != null) stack.push(temp.right)
        if (temp.left != null) stack.push(temp.left)
    }
    return res
};
```

> **说明**
>
> 栈的思想是先进后出
>
> 通过先判断右节点是否为空，将右先进，再让左进，这样弹出的时候就是从左边先弹了，刚好满足前序遍历的根左右思想

### 枚举

- 思想：列举所有可能的情况来解决问题
- 案例：统计移除递增子数组的数目

[leetcode](https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i/description/?envType=daily-question&envId=2024-07-10)

注意：移除递增子数组，是指移除这个子数组后，即原数组消掉子数组的元素后仍然递增，并不是说这个子数组一定是递增的，而且递增子数组不能为[]

- 实现思路

1. 枚举子数组
2. 移除每个枚举的子数组，判断移除子数组范围后的数组是否为递增
3. 单独检查首尾是否递增
4. 若前面均递增，则返回true，有一次不递增则返回false
5. 对返回true的，即符合题目条件的进行res++

```js
/**
 * @param {number[]} nums
 * @return {number}
 */

var incremovableSubarrayCount = function (nums) {
    // 存储移除递增子数组的总数
    let res = 0;
    for (let i = 0; i < nums.length; i++) {
        for (let j = i; j < nums.length; j++) {
            // 判断（i，j）的子数组是否为递增
            if (isIncreasing(nums, i, j)) {
                res++;
            }
        }
    }
    return res;
};

function isIncreasing(nums, l, r) {
    // 判断移除子数组范围后剩下的数组是否为递增
    for (let i = 1; i < nums.length; i++) {
        // 检查当前位置i是否在指定的子数组范围内，是则跳过
        // r + 1是因为我们判断剩余数组递增情况是要从有边界的两个元素开始进行比较    
        if (i >= l && i <= r + 1) {
            continue;
        }
        // 当前元素不大于上一个，说明是非递增
        if (nums[i] <= nums[i - 1]) {
            return false;
        }
    }

    // 检查子数组首尾元素是否递增
    if (l - 1 >= 0 && r + 1 < nums.length && nums[r + 1] <= nums[l - 1]) {
        return false;
    }

    return true;
}
```

### 双指针

- `js`没有显式的指针概念，但可以做到类似于指针的行为

**以合并两个有序数组 - 为例**
```js
var merge = function(nums1, m, nums2, n) {
    let p1=0,p2=0;
    let tempArr=new Array(m+n).fill(0);
    var cur;
    while(p1<m||p2<n){
        if(p1==m) cur=nums2[p2++];
        else if(p2==n) cur=nums1[p1++];
        else if(nums1[p1]<nums2[p2]) cur=nums1[p1++];
        else cur=nums2[p2++];
        tempArr[p1+p2-1]=cur;
    }
    for(let i=0;i!=m+n;i++){
        nums1[i]=tempArr[i];
    }
};
```

**移动零 ------->  快慢指针法**

```js
var moveZeroes = function (nums) {
    let slow_ptr = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            [nums[slow_ptr], nums[i]] = [nums[i], nums[slow_ptr]];
            slow_ptr++;
        }
    }
};
```

**双指针的双射应用**

```js
var wordPattern = function (pattern, s) {
    const word2ch = new Map();
    const ch2word = new Map();
    let arr = s.split(' ');
    if (arr.length != pattern.length) {
        return false;
    }
    for (const [i, word] of arr.entries()) {
        const ch = pattern[i];
        if (ch2word.has(ch) && ch2word.get(ch) != word || word2ch.has(word) && word2ch.get(word) != ch) {
            return false;
        }
        ch2word.set(ch, word);
        word2ch.set(word, ch);
    }
    return true;
};
```

### 快慢指针/前后指针

- 思想：即龟兔赛跑算法，常用于操作链表，一快一慢来遍历链表，能够寻找链表中间节点、检查是否有环、寻找链表起点、判断链表是否回文

**回文链表**

1. 通过快慢指针查找到链表的中间节点

   > **说明**：快慢两个指针同时出发，快指针每次走两步，慢指针每次走两步，当快指针走完的时候，慢指针刚好走到链表的中间节点
2. 对链表中间节点的后续进行反转
3. 从头节点和反转链表的头节点一一比较，如果相等继续到反转链表的结束后返回true，否则返回false

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var reverseLian = function (head) {
    let pre = null
    let cur = head
    // 不能使用!cur，如果使用!cur，当cur为null时，!cur它会返回true
    while (cur !== null) {
        const next = cur.next
        cur.next = pre
        pre = cur
        cur = next
    }
    return pre
}

var firstAndLast = function (head) {
    let fast = head
    let slow = head
    while (fast.next !== null && fast.next.next !== null) {
        fast = fast.next.next
        slow = slow.next
    }
    return slow
}

var isPalindrome = function (head) {
    let mid = firstAndLast(head)
    otherLian = reverseLian(mid.next)

    while (otherLian !== null) {
        if (head.val != otherLian.val) {
            return false;
        }
        head = head.next
        otherLian = otherLian.next
    }
    return true;
};
```

我们来看一下偶数的链表和奇数的链表有没有解决这个问题，因为考虑到你用快慢指针求中点，存在反转后半段的那个后半段可不可行

---

**[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)**

> **说明**
>
> 先让快指针先走n个节点
>
> 再让快慢指针同时走
>
> 当快指针的下一个节点为null或者不存在的时候
>
> 慢指针刚好就在要删除的节点的上一个位置

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    const res = new ListNode(0, head)
    let font = res
    let back = res
    while (n--) {
        font = font.next
    }
    // 不能写font.next!=null，font本身为null时会返回true
    // font本身为null，font.next会抛出错误
    while (font.next) {
        // 如果font本身为null，其next无法访问导致错误
        font = font.next
        back = back.next
    }
    back.next = back.next.next
    return res.next
};
```

### 排序

- 思想：将数据从小到大或者从大到小进行排序

- 案例

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**字母异位词分组**

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {
    // 创建map对象
    const word = new Map();
    for (let str of strs) {
        // 分解字符串的每个字母作为数组元素
        const arr = Array.from(str) // ['e','a','t']
        // 排序数组
        arr.sort() // ['a','e','t']
        // 转换为字符串
        curStr = arr.toString() // aet
        // 判断当前字符串是否是字母异位词
        const cur = word.get(curStr) ? word.get(curStr) : new Array()
        // 将当前字符串push上去
        cur.push(str)
        // 设置字母异位词
        word.set(curStr, cur)
    }
    // 
    return Array.from(word.values())
};
```

### 滑动窗口

- 思想：在数组中形成一个矩形窗口，每滑动一次处理一次

- 滑动窗口功能逻辑
  - 确定窗口的大小，对第一次确定的大小进行判断
  - 开始滑动，删掉第一个，往窗口后面追加一个，形成滑动效果，保持中间不变

删掉开头的c，追加末尾e

经典案例：[找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
    let res = []
    let pLen = p.length
    let sLen = s.length
    if (sLen < pLen) return []
    let pCount = new Array(26).fill(0)
    let sCount = new Array(26).fill(0)
    // 计算p有多少个字母
    for (let i = 0; i < pLen; i++) {
        pCount[p[i].charCodeAt() - 'a'.charCodeAt()]++
        sCount[s[i].charCodeAt() - 'a'.charCodeAt()]++
    }

    // 判断一开始的s子串是否是p的异位词
    if (sCount.toString() === pCount.toString()) {
        res.push(0)
    }

    // 滑动窗口，加一个删一个
    for (let i = 0; i < sLen - pLen; i++) {
        // 删掉窗口的第一个
        sCount[s[i].charCodeAt() - 'a'.charCodeAt()]--;
        // 往窗口后面追加一个
        sCount[s[i + pLen].charCodeAt() - 'a'.charCodeAt()]++;
        if (sCount.toString() === pCount.toString()) {
            res.push(i + 1)
        }
    }

    return res
};
```

**案例：判断是否存在相同元素**
```js
var containsNearbyDuplicate = function (nums, k) {
    let set = new Set();
    for (let i = 0; i < nums.length; i++) {
        if (i > k) set.delete(nums[i - k - 1]);
        if (set.has(nums[i])) return true;
        set.add(nums[i]);
    }
    return false;
};
```

### 前缀和

- 思想：在数组中，第i个元素表示前i个的和

- 应用场景：数组区间和、矩阵子矩阵和、动态规划、差分数组

**案例**：[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

实现步骤

1. 我们首先知道，整个数组[0,i]，从0到i的整个数组和为pre[i]
2. 现在我们要求子数组和为k的值，也就是会满足[j,i]这个区间的和为k
3. 我们假设pre[i]表示是[0...i]里所有数的和，可以得出一个结论：pre[i] = pre[i-1] + nums[i]
4. 那如果要求[j,i]的区间和为k的话，则我们可以把结论替换成：pre[i] - pre[j-1] =  k，即pre[j-1] = pre[i] - k
5. 此时结果是pre[j-1]则为满足条件的子数组，我们可以通过哈希来存取满足这个条件的子数组有多少个
6. 此时有个很大的问题，就是一开始没有解决pre[i] == sum的情况，所以要把这个情况先存进去

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {
    // 前缀和 + 哈希表
    let count = 0;
    let m = new Map();
    // 特殊情况，sum == k
    m.set(0, 1)
    let sum = 0
    for (let i = 0; i < nums.length; ++i) {
        sum += nums[i]
        if (m.has(sum - k)) {
            count += m.get(sum - k)
        }
        m.set(sum, m.has(sum) ? m.get(sum) + 1 : 1)
    }
    return count
};
```

### 原地

- 思想：不创建额外的空间来保存结果，直接修改结果，对数组来说就是修改原数组，而不是用一个新数组来保存

[矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

## 需求

---
**将视频文件绘制到`canvas`画布上，如何保持原画质不变**

**`html`部分**
```html
<canvas id="game"></canvas>
```

**`css`部分**
```css
#game {
    position: relative;
    border: 1px solid #000;
    width: 1200px;
}

#game canvas{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

**`js`部分**
```js
/**获取需要操作的元素 */
var canvas = document.querySelector('canvas');

// 创建video元素
let video = document.createElement('video');
video.src = '../sources/movie/Lost Princes.mp4';
video.loop = true;
// 隐藏视频元素
video.style.display = 'none';
// 添加到body中
document.body.appendChild(video);

function start() {
    firing.setAttribute(
        'style',
        'display:none;'
    );
    video.play();
    drawVideoTocanvas(video, canvas)
    canvas.removeEventListener('click', start);
}
canvas.addEventListener('click', start)

// 请求绘制视频到canvas当中
function drawVideoTocanvas(video, canvas) {
    // 设置canvas的宽度为1200px
    canvas.width = 1200;

    // 根据视频的原始宽高比计算适应的canvas高度
    let aspectRatio = video.videoWidth / video.videoHeight;
    canvas.height = canvas.width / aspectRatio;
    
    let ctx = canvas.getContext('2d');
    // 关闭图像平滑
    ctx.imageSmoothingEnabled = false;
    function draw() {
        if (!video.paused && !video.ended) {
            // 清除旧帧
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 绘制新帧
            ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, canvas.width, canvas.height);
            // 请求下一帧
            requestAnimationFrame(draw);
        }
    }
    draw();
}
```


---
textarea自动换行、不显示滚动条


1. 网上下载css的默认样式，导入（能够去除textarea手动拉伸）

2. 添加以下代码，index.html

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
       <link rel="stylesheet" href="./css/public.css">
       <style>
           textarea {
               /* 去除滚动条 */
               overflow: hidden;
           }
       </style>
   </head>
   
   <body>
       <textarea name="text" id="myTextarea" cols="30" rows="1"></textarea>
       <script>
           const textarea = document.querySelector('textarea');
           textarea.addEventListener('input', function () {
               this.style.height = 'auto';
               this.style.height = this.scrollHeight + 'px';
           });
   
       </script>
   </body>
   
   </html>
   ```

## 常见的报错

1. 报错`$ is not defined`

>由于`jQuery`库未被正确的引入而导致，只要引入`jQuery`库即可

在该js文件前，补充`jQuery`库，最好放在`head`处
```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alc枫</title>
    <link rel="icon" href="../image/maple-icon.ico">
    <link rel="stylesheet" href="../css/index.css">
    <!-- 引入jQuery库 -->
    <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
</head>
```

2. 函数中使用变量，出现变量未定义的情况

>可能由于在函数的函数里使用了变量，形成了闭包函数的情况，此时在函数里要把变量的类型定义为`let`变量，
>
>否则会由于`var`导致变量的值一直在变化，而导致无法定义，使用局部变量`let`

```js
// 获取数字的所有样式
var num=document.querySelectorAll('.span span');
// console.log(num);

// 获取所有图片的样式
var img=document.querySelectorAll('.lunbo img')
// console.log(img);

// 鼠标点击切换图片样式
mouse_img()
function mouse_img() {
    // 此处要用let，不能用var
    for (let i = 0; i < 4; i++) {
        // console.log(num[i]);
        num[i].onmousemove=function(){  
            num[i].setAttribute(
                'style',
                'background-color:green;'
            );
        }
    }
}
```

## 无法导包

`(index):65 Uncaught SyntaxError: Cannot use import statement outside a module (at (index):65:9)`

这种语法报错是说无法通过import导入外部的包

这是因为script标签里面是不支持ES6语法的，如果要在script标签里面通过import导包需要通过声明module类型

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas id="c"></canvas>
    <div id="ui"></div>
    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    </script>
</body>

</html>
```

