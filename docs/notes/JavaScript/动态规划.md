---
title: 动态规划
createTime: 2025/03/31 10:02:35
permalink: /JavaScript/6arp5uws/
---
[toc]

# 思想

- 动态规划（Dynamic Programming, DP）思想
- 将原问题分解为多个子问题，**利用子问题的解**来构造原问题的解
- 有一个特点，子问题会重复计算，不过可以通过存储已经计算过子问题的解避免重复计算，由于这个特点，DP思想的**时间复杂度至少为O（n*target）**，n是数组的长度，target是数组和一半
- 优化方面（并不是优化时间复杂度，要知道至少的含金量），原问题的解能够通过子问题的最优解来构造，即原问题的解必然是子问题解的组合

# 解题步骤

- 定义状态：确定一个状态表示子问题的解，状态一般**用变量或者数组**表示
- 边界条件：定义初始条件，表示最小的子问题，通常为**0或者1**（并不局限于两种情况，可能是与0有关的整个循环）
- 状态转移方程：通过已有的子问题解来求解当前子问题的关系
- 迭代求解：通过前两步，从最小的子问题开始，推导出更大的子问题的解，最终得到原问题的解
- 返回结果：通常是数组的最后一个元素

# 如何促成解题步骤

## 定义状态

- 考虑如何使用一个数组来表示这个信息
- 定义状态，即**定义子问题的解**，要包含所有的情况，暴力起来！！！
- 可以从题目的问题出发，以案例使用最小花费爬楼梯来说，**题目的问题是计算并返回达到楼梯顶部的最低花费**，那么它的子问题的解可以是，到达某个楼梯的最小花费是多少，这个就是它的状态定义，`dp[i]`，表示到达第`i`个台阶的最小花费
- 例如背包问题（多维动态规划），定义`dp[i][j]`表示为前`i`个物品中能否恰好装满容量为`j`的背包

## 边界条件

- 最简单的子问题的解，一般是**“空问题”**或者**某种基础状态**
- “空问题”就是不存在的子问题的解，但是它又是边界条件，是迭代求解的前提
- 比如分割等和子集，这个数组包含正整数且非空，那么和为0就是不存在的子问题的解，但是它又是边界条件，是迭代求解的前提

## 状态转移方程

- 找到**子问题间的关系**
- 一般的式子都是，dp[i]、dp[i-1]、dp[i-2]……和n的关系

## 迭代求解

- 通过自顶向下或者自底向上的方法，依次求解子问题，最后得到原问题的解
- 例如背包问题，遍历所有的物品和容量，依次更新`dp`数组

## 返回结果

- 通常，数组的最后一项就是答案

# 案例解析

## 使用最小花费爬楼梯

[使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/?envType=study-plan-v2&envId=dynamic-programming)

```bash
746. 使用最小花费爬楼梯
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
 

提示：
2 <= cost.length <= 1000
0 <= cost[i] <= 999
```

- 如何定义状态，从题目的问题出发
- 定义状态，其实就是找子问题的解
- **题目的问题是计算并返回达到楼梯顶部的最低花费**，那么它的子问题的解可以是，到达某个楼梯的最小花费是多少，这个就是它的状态定义，`dp[i]`，表示到达第`i`个台阶的最小花费

## 编辑距离

[编辑距离](https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

```bash
72. 编辑距离
给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
 

提示：

0 <= word1.length, word2.length <= 500
word1 和 word2 由小写英文字母组成
```

- 这里**边界条件**需要考虑基础状态
- 比如当words1或者words2为空字符串的时候，它们转换到对方是由对方的字符串长度决定的
- 需要边界条件的另一个核心是，在写这题的状态转移方程时，需要用到i和i-1的关系，好像也可以不用（）
- **状态转移方程**有四种方程，字符相同以及不同时的替换、插入和删除
- 双方新的字符相同，无需操作，直接相等即可
- 双方新的字符不同，可以进行替换、插入和删除操作
- 替换字符数是不变的，对上一个结果计数加一即可
- 进行插入操作是因为words2多了一个字符，由words1去补这个字符
- words1 = 'abc'，words2 = 'abcd'，因此要在`dp[i][j-1]`的结果计数加一
- 进行删除操作则是同理，反向思考一下
- **迭代求解**要如何使用状态转移方程呢
- 在整个迭代过程中，无非就是每次多一个单词进行处理，然而字符不同的时候你只能进行三个操作的其中一个去完成任务
- 因为你只要从三个操作里面选出最少的那个不就行了，题目就是要求最少操作数（魔法操作）
- 当然最后空字符串的处理，其实初始化的时候只要平移一下就好了



