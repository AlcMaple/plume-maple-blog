---
title: 进阶
createTime: 2025/03/31 10:02:35
permalink: /JavaScript/x5lvchi0/
---
[toc]

# Swapy拖动工具

- 作用：可以将布局随意交换位置
- 应用场景：对某些列表项随意交换位置，实现自定义排序

[官方文档](https://swapy.tahazsh.com/)

[github地址](https://github.com/TahaSh/swapy?tab=readme-ov-file)

## 安装

- 方法一：`pnpm install swapy`

> 可以使用你喜欢的包管理工具安装

- 方法二：使用CDN获取

```js
<script src="https://unpkg.com/swapy/dist/swapy.min.js"></script>
<script>
  // You can then use it like this
  const swapy = Swapy.createSwapy(container)
</script>
```

## 使用Swapy

- 第一步：指定插槽和项目

data-swapy-slot="anyNameYouWant"：指定槽，每个槽只能包含一个项目，项目是要拖放的内容

data-swapy-item="anyNameYouWant"：将某个元素标记为项目

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            text-align: center;
            align-content: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        .section-1,
        .section-2,
        .section-3 {
            width: 100%;
            height: 300px;
            margin-bottom: 20px;
            position: relative;
        }

        .content-a,
        .content-b,
        .content-c {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            background-color: antiquewhite;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="section-1" data-swapy-slot="foo">
            <div class="content-a" data-swapy-item="a">
                <!-- Your content for content-a goes here -->
                aaaa
            </div>
        </div>

        <div class="section-2" data-swapy-slot="bar">
            <div class="content-b" data-swapy-item="b">
                <!-- Your content for content-b goes here -->
                bbbb
                <div class="handle" data-swapy-handle>
                    bbbb--2222
                </div>
            </div>
        </div>

        <div class="section-3" data-swapy-slot="baz">
            <div class="content-c" data-swapy-item="c">
                cccc
                <!-- Your content for content-c goes here -->
            </div>
        </div>
    </div>

    
</body>

</html>
```

- 第二步：配置使用Swapy功能

```html
<script src="https://unpkg.com/swapy/dist/swapy.min.js"></script>
<script>
	 const container = document.querySelector('.container')
</script>
```

如果你是通过pnpm包管理工具安装的话，需要通过导入的形式去配置使用

```js
import { createSwapy } from 'swapy'

const container = document.querySelector('.container')

const swapy = createSwapy(container, {
  animation: 'dynamic' // or spring or none
})

// You can disable and enable it anytime you want
swapy.enable(true)
```

## Vue3使用`swapy`

现在我们将swapy运用到vue3里面，我在`npm install swapy`安装swapy库的时候，无法安装

于是我采用了其他方式，不通过npm去安装库，像html那样导入库

```vue
<template>
  <div>
    <div class="container" ref="container">
      <div class="section-1" data-swapy-slot="foo">
        <div class="content-a" data-swapy-item="a">
          <!-- Your content for content-a goes here -->
          aaaa
        </div>
      </div>

      <div class="section-2" data-swapy-slot="bar">
        <div class="content-b" data-swapy-item="b">
          <!-- Your content for content-b goes here -->
          bbbb
          <div class="handle" data-swapy-handle>bbbb--2222</div>
        </div>
      </div>

      <div class="section-3" data-swapy-slot="baz">
        <div class="content-c" data-swapy-item="c">
          cccc
          <!-- Your content for content-c goes here -->
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { onMounted, ref } from "vue";

export default {
  setup() {
    // 通过创建一个响应式引用，以便createSwapy方法操作这个元素
    const container = ref(null);

    onMounted(() => {
      const script = document.createElement("script");
      script.src = "https://unpkg.com/swapy/dist/swapy.min.js";
      // 当swapy库完成加载完成后触发
      script.onload = () => {
        // eslint-disable-next-line no-undef
        const swapy = Swapy.createSwapy(container.value, {
          animation: "dynamic",
        });
        swapy.enable(true);
      };
      document.head.appendChild(script);
    });

    // 返回响应式引用，以便在模板中使用
    return { container };
  },
};
</script>

<style scoped>
* {
  padding: 0;
  margin: 0;
  text-align: center;
  align-content: center;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

.section-1,
.section-2,
.section-3 {
  width: 100%;
  height: 300px;
  margin-bottom: 20px;
  position: relative;
}

.content-a,
.content-b,
.content-c {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 2rem;
  color: #fff;
  text-shadow: 1px 1px 2px #000;
  background-color: antiquewhite;
}
</style>
```

效果  和  使用Swapy  里的效果是一样的

# 音频可视化

直接上代码

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./index.css">
</head>

<body>
    <!-- 绘制音频波形 -->
    <canvas></canvas>
    <audio src="./1.mp3" controls></audio>
    <script src="./index.js"></script>
</body>

</html>
```

```css
canvas {
    border-bottom: 1px solid #ccc;
}

audio {
    display: block;
    text-align: center;
    margin: 0 auto;
}
```

```js
const audioEle = document.querySelector('audio')
const cvs = document.querySelector('canvas')
const ctx = cvs.getContext('2d')
// 初始化canvas尺寸
function initCvs() {
    cvs.width = window.innerWidth * devicePixelRatio;
    cvs.height = (window.innerHeight / 2) *
        devicePixelRatio
}
initCvs()

let isInit = false;
// 绘图需要数组数据，随着音乐播放需要分析器不停的分析，因此这两个放在全局
let dataArray, analyser;
// 音频播放时触发
audioEle.onplay = function () {
    if (isInit) {
        return;
    }
    // 初始化
    const audCtx = new AudioContext(); // 创建音频上下文
    // 音频处理环节：音调调高调低、修音、声音混淆等，每一个环节为一个节点
    const source = audCtx.createMediaElementSource(audioEle) // 创建音频源节点（音频数据的来源），这里将元素作为音频来源
    // 分析器节点：分析音频源的音频数据的波形
    analyser = audCtx.createAnalyser()
    // 变换的窗口大小，必需是2^n，默认2048，窗口越大，分析出来的结果就越细腻
    analyser.fftSize = 512
    // 创建无符号八位数组，接收分析器节点分析的数据，即转换为频率图的数据
    dataArray = new Uint8Array(analyser.frequencyBinCount) // 频率图是对称的,通过analyser.frequencyBinCount将获取窗口大小的一半
    // 连接：将音频源的数据输出到分析器节点
    source.connect(analyser)
    // 连接：将分析器节点与输出设备进行连接，以便听到声音
    analyser.connect(audCtx.destination)

    isInit = true
}

// 把分析出的波形绘制到canvas
function draw() {
    requestAnimationFrame(draw)
    // 清空画布
    const { width, height } = cvs;
    ctx.clearRect(0, 0, width, height)
    // 判断是否有初始化
    if (!isInit) {
        return
    }
    // 让分析器节点分析出数据到数组中
    analyser.getByteFrequencyData(dataArray)
    // 将数据绘制到canvas，除2.5解决音频中低频较多，右边几乎没信号，因此通过放大倍数来调整
    const len = dataArray.length / 2.5
    // 计算条的宽度，除以2是因为要画对称，本来canvas只能绘制音频的一半，你前面不是放大倍数来嘛
    const barWith = width / len / 2
    // 绘制颜色
    ctx.fillStyle = '#78C5F7'
    for (let i = 0; i < len; i++) {
        const data = dataArray[i]
        // 计算条的高度
        const barHeight = data / 255 * height;
        // 画布的横坐标，由于要画对称，所以加上宽度除以2，从中间开始画，后面再补前半部分
        const x1 = i * barWith + width / 2
        // 画前半部分
        const x2 = width / 2 - (i + 1) * barWith
        // 画布的纵坐标
        const y = height - barHeight
        // 绘制，这里-2是解决条过于密集，让它有点空隙
        ctx.fillRect(x1, y, barWith - 2, barHeight)
        ctx.fillRect(x2, y, barWith - 2, barHeight)
    }
}
draw()
```

效果如下

![[musicSee.gif]]
# 代码着色

## 基本使用

你是否有见过`chatgpt`回复你的时候，不同的语言代码都具备相应的着色

今天我们要做的就是这个

首先，这里是用了一个[库](https://github.com/highlightjs/highlight.js)

使用这个库，有两种方式，和Swapy一样，可以通过npm或者csdn加载

我这里为了方便演示，会两个都同时用，你用一个就好了啊

首先我在我代码里面写了个基础的js语法代码，并且通过csdn加载这个库(需要同时加载js和css才行)



然后我前面说了，我两个都用，因此我用csdn加载js，然后顺便也用npm安装一下，再通过相对路径去使用css

`npm install highlight.js`

由于npm经常会有网络问题，所以可以使用yarn：`yarn add highlight.js`

其实具体的安装和导入主要看官方GitHub，这里以使用为主

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./node_modules/highlight.js/styles/github-dark.css">
</head>

<body>
    <pre>
        <code id="code-area">
const audioEle = document.querySelector('audio')
const cvs = document.querySelector('canvas')
const ctx = cvs.getContext('2d')
// 初始化canvas尺寸
function initCvs() {
    cvs.width = window.innerWidth * devicePixelRatio;
    cvs.height = (window.innerHeight / 2) *
        devicePixelRatio
}
initCvs()

let isInit = false;
// 绘图需要数组数据，随着音乐播放需要分析器不停的分析，因此这两个放在全局
let dataArray, analyser;
// 音频播放时触发
audioEle.onplay = function () {
    if (isInit) {
        return;
    }
    // 初始化
    const audCtx = new AudioContext(); // 创建音频上下文
    // 音频处理环节：音调调高调低、修音、声音混淆等，每一个环节为一个节点
    const source = audCtx.createMediaElementSource(audioEle) // 创建音频源节点（音频数据的来源），这里将元素作为音频来源
    // 分析器节点：分析音频源的音频数据的波形
    analyser = audCtx.createAnalyser()
    // 变换的窗口大小，必需是2^n，默认2048，窗口越大，分析出来的结果就越细腻
    analyser.fftSize = 512
    // 创建无符号八位数组，接收分析器节点分析的数据，即转换为频率图的数据
    dataArray = new Uint8Array(analyser.frequencyBinCount) // 频率图是对称的,通过analyser.frequencyBinCount将获取窗口大小的一半
    // 连接：将音频源的数据输出到分析器节点
    source.connect(analyser)
    // 连接：将分析器节点与输出设备进行连接，以便听到声音
    analyser.connect(audCtx.destination)

    isInit = true
}

// 把分析出的波形绘制到canvas
function draw() {
    requestAnimationFrame(draw)
    // 清空画布
    const { width, height } = cvs;
    ctx.clearRect(0, 0, width, height)
    // 判断是否有初始化
    if (!isInit) {
        return
    }
    // 让分析器节点分析出数据到数组中
    analyser.getByteFrequencyData(dataArray)
    // 将数据绘制到canvas，除2.5解决音频中低频较多，右边几乎没信号，因此通过放大倍数来调整
    const len = dataArray.length / 2.5
    // 计算条的宽度，除以2是因为要画对称，本来canvas只能绘制音频的一半，你前面不是放大倍数来嘛
    const barWith = width / len / 2
    // 绘制颜色
    ctx.fillStyle = '#78C5F7'
    for (let i = 0; i < len; i++) {
        const data = dataArray[i]
        // 计算条的高度
        const barHeight = data / 255 * height;
        // 画布的横坐标，由于要画对称，所以加上宽度除以2，从中间开始画，后面再补前半部分
        const x1 = i * barWith + width / 2
        // 画前半部分
        const x2 = width / 2 - (i + 1) * barWith
        // 画布的纵坐标
        const y = height - barHeight
        // 绘制，这里-2是解决条过于密集，让它有点空隙
        ctx.fillRect(x1, y, barWith - 2, barHeight)
        ctx.fillRect(x2, y, barWith - 2, barHeight)
    }
}
draw()
        </code>
    </pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js"></script>
</body>

</html>
```

> **注意**
>
> 这里不要格式化代码噢，因为考虑到你的code标签会带括号

基础框架搭好了，这边开始代码着色，非常简单

```html
<script>
	const codeElem = document.querySelector('#code-area')
	// 代码高亮，不给第二个参数会自动识别代码进行高亮
	// hljs.highlightElement(codeElem)
  
  // 手动指定颜色避免识别错误
	hljs.highlightElement(codeElem, {
		language: 'javascript',
	});
</script>
```

下面来解释一下，一般情况下我们是需要自己加两个样式的，现在

```js
hljs.highlightElement(codeElem, {
		language: 'javascript',
	});
```

通过这个方法，它能够为codeElem这个元素添加hljs样式和language-javascript样式

因此可以实现不同代码自动识别加入相对应的样式

## 企业级使用

企业级使用，通过ajax请求纯数据，然后进行代码着色

这里我就拿静态数据进行请求了

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css">
</head>

<body>
    <pre>
        <code id="code-area"></code>
    </pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>
        const code = {
            lang: 'javascript',
            content: `
const audioEle = document.querySelector('audio')
const cvs = document.querySelector('canvas')
const ctx = cvs.getContext('2d')
// 初始化canvas尺寸
function initCvs() {
    cvs.width = window.innerWidth * devicePixelRatio;
    cvs.height = (window.innerHeight / 2) *
        devicePixelRatio
}
initCvs()

let isInit = false;
// 绘图需要数组数据，随着音乐播放需要分析器不停的分析，因此这两个放在全局
let dataArray, analyser;
// 音频播放时触发
audioEle.onplay = function () {
    if (isInit) {
        return;
    }
    // 初始化
    const audCtx = new AudioContext(); // 创建音频上下文
    // 音频处理环节：音调调高调低、修音、声音混淆等，每一个环节为一个节点
    const source = audCtx.createMediaElementSource(audioEle) // 创建音频源节点（音频数据的来源），这里将元素作为音频来源
    // 分析器节点：分析音频源的音频数据的波形
    analyser = audCtx.createAnalyser()
    // 变换的窗口大小，必需是2^n，默认2048，窗口越大，分析出来的结果就越细腻
    analyser.fftSize = 512
    // 创建无符号八位数组，接收分析器节点分析的数据，即转换为频率图的数据
    dataArray = new Uint8Array(analyser.frequencyBinCount) // 频率图是对称的,通过analyser.frequencyBinCount将获取窗口大小的一半
    // 连接：将音频源的数据输出到分析器节点
    source.connect(analyser)
    // 连接：将分析器节点与输出设备进行连接，以便听到声音
    analyser.connect(audCtx.destination)

    isInit = true
}

// 把分析出的波形绘制到canvas
function draw() {
    requestAnimationFrame(draw)
    // 清空画布
    const { width, height } = cvs;
    ctx.clearRect(0, 0, width, height)
    // 判断是否有初始化
    if (!isInit) {
        return
    }
    // 让分析器节点分析出数据到数组中
    analyser.getByteFrequencyData(dataArray)
    // 将数据绘制到canvas，除2.5解决音频中低频较多，右边几乎没信号，因此通过放大倍数来调整
    const len = dataArray.length / 2.5
    // 计算条的宽度，除以2是因为要画对称，本来canvas只能绘制音频的一半，你前面不是放大倍数来嘛
    const barWith = width / len / 2
    // 绘制颜色
    ctx.fillStyle = '#78C5F7'
    for (let i = 0; i < len; i++) {
        const data = dataArray[i]
        // 计算条的高度
        const barHeight = data / 255 * height;
        // 画布的横坐标，由于要画对称，所以加上宽度除以2，从中间开始画，后面再补前半部分
        const x1 = i * barWith + width / 2
        // 画前半部分
        const x2 = width / 2 - (i + 1) * barWith
        // 画布的纵坐标
        const y = height - barHeight
        // 绘制，这里-2是解决条过于密集，让它有点空隙
        ctx.fillRect(x1, y, barWith - 2, barHeight)
        ctx.fillRect(x2, y, barWith - 2, barHeight)
    }
}
draw()`
        }
        if (typeof hljs === 'undefined') {
            console.log('hljs is not defined');

        } else {
            const result = hljs.highlight(code.content, {
                language: code.lang,
            });
            const codeElem = document.getElementById('code-area');
            codeElem.innerHTML = result.value;
        }
    </script>
</body>

</html>
```

如果你在运行中，你的库报错了，估计是库不行，要换个库

此时你会发现代码还是有点问题，它的背景是白色的

通过阿贾克斯的方式，它无法给code-area这个标签添加css样式元素，需要自己手动去添加，所以稍微修改下代码即可

```js
codeElem.className = `hljs language-${code.lang}`;
```

现在可以看到有背景色了

# 粒子时钟

初始化项目结构

index.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }

        canvas{
            background: radial-gradient(#fff, #8c738c);
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
   <canvas></canvas>
   <script src="./index.js"></script>
</body>

</html>
```

index.js

```js
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d',{
    // 提升性能
    willReadFrequently: true
});

function initCanvasSize() {
    // *devicePixelRatio,解决清晰度问题
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
}

initCanvasSize();

/**
 * 获取[min,max]范围内的随机整数
 */
function getRandom(min,max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
```

现在看到的效果只是一个渐变色背景

现在第一步，生成一个粒子

```js
class Particle {
    constructor() {
        // 大圆的半径
        const r = Math.min(canvas.width, canvas.height) / 2;
        // 圆的中心点
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        // 随机角度,计算弧度
        const rad = getRandom(0, 360) * Math.PI / 180;
        this.x = cx + r * Math.cos(rad);
        this.y = cy + r * Math.sin(rad);
        // 粒子半径大小随机
        this.size = getRandom(2 * devicePixelRatio, 7 * devicePixelRatio);
    }

    draw(){
        ctx.beginPath();
        ctx.fillStyle = '#5445544d';
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
        ctx.fill()
    }
}

const p = new Particle();
p.draw();
```

现在可以通过循环去绘制所有的点，以达到一个圈的效果

```js
const partciles = [];

for (let i = 0; i < 1000; i++) {
    partciles.push(new Particle());
}

// 画出所有的粒子
function draw(){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    partciles.forEach(p => {
        p.draw();
    });
    requestAnimationFrame(draw);
}

// const p = new Particle();
draw();
```

现在要搞定一个点的运动，这里考验的数学能力非常强，需要自己去计算

在类中添加moveTo函数

```js
moveTo(tx, ty) {
    const duration = 500;
    const sx = this.x;
    const sy = this.y;
    const xSpeed = (tx - sx) / duration;
    const ySpeed = (ty - sy) / duration;
    const startTime = Date.now();
    const _move = () => {
        const t = Date.now() - startTime;
        const x = sx + xSpeed * t;
        const y = sy + ySpeed * t;
        this.x = x;
        this.y = y;
        if (t >= duration) {
            this.x = tx;
            this.y = ty;
            return
        }
        requestAnimationFrame(_move)
    }
    _move();
}
```

门槛太高了，直接上源码吧，html不变，js源码如下

```js
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d', {
    // 提升性能
    willReadFrequently: true
});

function initCanvasSize() {
    // *devicePixelRatio,解决清晰度问题
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
}

initCanvasSize();

/**
 * 获取[min,max]范围内的随机整数
 */
function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

class Particle {
    constructor() {
        // 大圆的半径
        const r = Math.min(canvas.width, canvas.height) / 2;
        // 圆的中心点
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        // 随机角度,计算弧度
        const rad = getRandom(0, 360) * Math.PI / 180;
        this.x = cx + r * Math.cos(rad);
        this.y = cy + r * Math.sin(rad);
        // 粒子半径大小随机
        this.size = getRandom(2 * devicePixelRatio, 7 * devicePixelRatio);
    }

    draw() {
        ctx.beginPath();
        ctx.fillStyle = '#5445544d';
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
        ctx.fill()
    }

    moveTo(tx, ty) {
        const duration = 500;
        const sx = this.x;
        const sy = this.y;
        const xSpeed = (tx - sx) / duration;
        const ySpeed = (ty - sy) / duration;
        const startTime = Date.now();
        const _move = () => {
            const t = Date.now() - startTime;
            const x = sx + xSpeed * t;
            const y = sy + ySpeed * t;
            this.x = x;
            this.y = y;
            if (t >= duration) {
                this.x = tx;
                this.y = ty;
                return
            }
            requestAnimationFrame(_move)
        }
        _move();
    }
}

const partciles = [];

// for (let i = 0; i < 1000; i++) {
//     partciles.push(new Particle());
// }

// const p = new Particle();
// partciles.push(p);

let text = null;
function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}


// 画出所有的粒子
function draw() {
    clear()
    update();
    partciles.forEach(p => {
        p.draw();
    });
    requestAnimationFrame(draw);
}

// const p = new Particle();
draw();

function getText() {
    // 获取当前时间
    return new Date().toTimeString().substring(0, 8);
}


// 绘制文字
function update() {
    const newText = getText();
    // 绘制过的文本
    if (newText === text) {
        return
    }
    clear();
    text = newText;

    const { width, height } = canvas;
    // 画文本
    ctx.fillStyle = '#000';
    // 文本位置居中
    ctx.textBaseline = 'middle'
    ctx.font = `${140 * devicePixelRatio}px 'DS-Digital', sans-serif`
    ctx.fillText(text, (width - ctx.measureText(text).width) / 2, height / 2)
    const points = getPoints();
    clear();
    // console.log(points.length);
    for (let i = 0; i < points.length; i++) {
        let p = partciles[i];
        if (!p) {
            p = new Particle();
            partciles.push(p);
        }
        const [x, y] = points[i];
        p.moveTo(x, y);
    }
    if (points.length < partciles.length) {
        partciles.splice(points.length);
    }
}

function getPoints() {
    const { width, height, data } = ctx.getImageData(0, 0, canvas.width, canvas.height)

    const points = [];
    const gap = 6;
    for (let i = 0; i < width; i += gap) {
        for (let j = 0; j < height; j += gap) {
            const index = (j * width + i) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            if (r === 0 && g === 0 && b === 0 && a === 255) {
                // console.log(r, g, b, a);
                points.push([i, j])
            }
        }
    }
    // console.log(data);
    return points;
}
```

# 跟随光标流光

给出基本结构

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body{
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            /* 设置子元素间距 */
            gap: 50px;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <!-- 定义颜色变量--clr:#0f0;控制发光不一样 -->
    <a href="#" style="--clr:#0f0;"><span>BUTTON</span></a>
    <a href="#" style="--clr:#ff0;"><span>BUTTON</span></a>
    <a href="#" style="--clr:#f0f;"><span>BUTTON</span></a>
</body>
</html>
```

接下来编写按钮的样式

```css
/* 按钮的样式 */
a{
    position: relative;
    padding: 20px 60px;
    background-color: rgba(45, 45, 45,1);
    border-radius: 50px;
    color: #999;
    font-size: 1.5em;
    text-decoration: none;
    /* 为鼠标经过作铺垫 */
    transition: .5s;
}
```

现在编写经过按钮时，字体颜色能够发生变化

```css
a:hover {
    color: var(--clr);
    text-shadow: 0 0 15px var(--clr), 0 0 40px var(--clr);
}
```

接下来编写外部发光效果

```css
a::before{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
    background: radial-gradient(var(--clr), transparent,transparent);
}
```

现在进行调整，隐藏这个外部的光，鼠标经过再显示

由于鼠标经过会有一个边框的流动效果

```css
    a::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        background: radial-gradient(var(--clr), transparent, transparent);
        opacity: 0;
        transition: .5s;
    }
    a:hover::before {
        opacity: 1;
    }
    a::after{
        content: '';
        background-color: rgba(45, 45, 45, .8);
        position: absolute;
        /* 定义四条边的距离 */
        inset: 2px;
    }
```
接下来把这四条边的距离设置为圆，然后由于伪元素遮挡住了文字，因此设置层级

```css
a span{
    position: relative;
    z-index: 1;
    letter-spacing: .2em;
}

a::after {
    content: '';
    background-color: rgba(45, 45, 45, .8);
    position: absolute;
    /* 定义四条边的距离 */
    inset: 2px;
    border-radius: 48px;
}
```

最后为a样式作溢出隐藏，就能达到流体的静态效果了

现在处理动态效果，动态效果也就是更改a::before的top和left值

```css
top: var(--y);
left: var(--x);
```

```js
let btns = document.querySelectorAll('a');
btns.forEach(btn => {
    btn.onmouseover = (e) => {
        // 重新赋值top和left值
        let x = e.pageX - btn.offsetLeft;
        let y = e.pageY - btn.offsetTop;
        // 定义两个变量进行赋值
        btn.style.setProperty('--x', x + 'px');
        btn.style.setProperty('--y', y + 'px');
    }
})
```

现在可以看到动态效果了，但是有个问题就是不够平滑平顺，很明显的卡帧效果

一个是因为a::before的transition，没有指定哪一个使用导致top和left更新会有延时

因此删除a的transition，修改了a::before的transition

但是这样还是不能够解决问题

就是`js`的渲染问题没有得到足够的优化，还有就是使用onmousemove没有直接使用mousemove渲染更好

因此最终调整的版本为下面源码

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Glowing Cursor Buttons</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            gap: 50px;
            flex-direction: column;
        }

        a {
            position: relative;
            padding: 20px 60px;
            background-color: rgba(45, 45, 45, 1);
            border-radius: 50px;
            color: #999;
            font-size: 1.5em;
            text-decoration: none;
            overflow: hidden;
        }

        a span {
            position: relative;
            z-index: 1;
            letter-spacing: .2em;
        }

        a:hover {
            color: var(--clr);
            text-shadow: 0 0 15px var(--clr), 0 0 40px var(--clr);
        }

        a::before {
            content: '';
            position: absolute;
            top: var(--y);
            left: var(--x);
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            background: radial-gradient(var(--clr), transparent, transparent);
            opacity: 0;
            transition: opacity 0.5s;
        }

        a:hover::before {
            opacity: 1;
        }

        a::after {
            content: '';
            background-color: rgba(45, 45, 45, .8);
            position: absolute;
            inset: 2px;
            border-radius: 48px;
        }
    </style>
</head>

<body>
    <a href="#" style="--clr:#0f0;"><span>BUTTON</span></a>
    <a href="#" style="--clr:#ff0;"><span>BUTTON</span></a>
    <a href="#" style="--clr:#f0f;"><span>BUTTON</span></a>

    <script>
        let btns = document.querySelectorAll('a');
        let rafId = null;

        btns.forEach(btn => {
            // 通过性能优化来解决鼠标移动过快导致的渲染问题
            btn.addEventListener('mousemove', (e) => {
                if (rafId) {
                    cancelAnimationFrame(rafId);
                }
                rafId = requestAnimationFrame(() => {
                    updateButtonGlow(btn, e);
                });
            });

            btn.addEventListener('mouseleave', () => {
                btn.style.setProperty('--x', '50%');
                btn.style.setProperty('--y', '50%');
            });
        });

        function updateButtonGlow(btn, e) {
            const rect = btn.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            btn.style.setProperty('--x', x + 'px');
            btn.style.setProperty('--y', y + 'px');
        }
    </script>
</body>

</html>
```

# Object对象

## assign方法

- 语法：`Object.assign(target, ...sources)`

- 作用：将对象的多个属性复制到target对象中

# 数组

## 数组复制

有一种需求，把数组的每一个对象的某个属性，赋值到另一个数组的每一个对象的某个属性

要做这个的前提是，两个数组的长度要想等

为了避免被赋值的数组长度与复制的数组长度不一样，我们需要做数组的复制

传统的复制

```js
this.configList = new Array(this.form.nodes.length).fill({
	auditStaffIds: '',
	nodeName: '',
})
```

这种复制不能达到上面的需求，因为通过new Array进行复制，所有元素都指向同一个对象，当一个元素进行变更的时候，其他也会跟着变更，达到同步的效果

因此需要使用map方法对每个元素生成一个新的对象

```js
this.configList = this.form.nodes.map(() => ({
	auditStaffIds: '',
	nodeName: '',
}))
```

这样你做需求的时候就不会影响啦

```js
if (this.configList[index]) {
	this.configList[index].nodeName = node.nodeName
	this.configList[index].auditStaffIds = node.auditors.map((a) => a.staffId).join(',')
}
```

## slice方法

- 作用：返回一个新数组的子数组，不修改原数组，相当于字符串的substring方法

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
    let res = [];
    for (let i = 0; i <= nums.length - k; i++) {
        // 使用 slice 获取当前窗口的子数组，不会修改原数组
        let window = nums.slice(i, i + k);
        // 获取子数组的最大值
        res.push(Math.max(...window));
    }
    return res;
};
```

## `Uint8Array`

- 存储 8 位无符号**整数**的类型化数组
- 每个元素的值范围是 0 到 255（即 2^8 - 1）
- 最大可以存储 2^32 - 1 个元素（即 4,294,967,295 个元素）
- 与Array的区别
  - 内存占用更少（Array 存储的是引用类型）
  - 性能更好（因为是连续的内存空间）
  - 类型固定，不会发生类型转换

## 元素间交换

`[nums[slow_ptr], nums[i]] = [nums[i], nums[slow_ptr]];`

## `indexOf`与哈希

- `indexOf`与哈希的has方法都是查找元素
- 但是它们之间的区别很大，前者是O(n)，`indexOf`底层就是遍历一次数组去找这个元素
- 哈希has是O(1)，它基于哈希表的数据结构，时间复杂度与数组长度无关

## `indexOf`和`includes`

- 前者会返回找到的第一个的起始位置，后者找到只会返回true

## 排序优化

- 最强排序方案，O（n）秒杀，你熟知的 sort 方法如果数据分布不均匀，可能会退化到 **O(n log n)**

- ```js
  /**
   * @param {number[]} nums1
   * @param {number} m
   * @param {number[]} nums2
   * @param {number} n
   * @return {void} Do not return anything, modify nums1 in-place instead.
   */
  var merge = function (nums1, m, nums2, n) {
      for (let i = m, j = 0; j < nums2.length; i++, j++) {
          nums1[i] = nums2[j]
      }
  
      // 升序
      // nums1.sort((a, b) => {
      //     return a - b
      // })
  
      // 优化排序
      let min = Math.min(...nums1); // 找到最小值
      let max = Math.max(...nums1); // 找到最大值
      let range = max - min + 1;  // 计算范围大小
  
      let count = new Array(range).fill(0); // 创建计数数组
  
      // 统计每个数出现的次数
      for (let num of nums1) {
          count[num - min]++; // 关键：用 num - min 作为索引，偏移负数
      }
  
      // 【1,2,3,2,5,6】  1 ---- 6
      // count 【1，2，1，0，1，1】
  
      // [-1,0,0,3,3,3,1,2,2]  -1 ----- 3
      // count 【0，……】
  
      // 还原排序数组，这是升序做法，如果是降序只要微调就行
      let index = 0;
      for (let i = 0; i < range; i++) {
          while (count[i] > 0) {
              nums1[index++] = i + min; // 恢复原值
              count[i]--;
          }
      }
  };
  ```

- 还有更加特殊的需求，如果你是二维数组，并且按数组中每个数组的第一个元素排序，也是能用这个优化排序方法

- ```js
  function sortNestedArrays(arrays) {
      // 找到第一个元素的最小值和最大值
      let min = Infinity;
      let max = -Infinity;
      
      for (let arr of arrays) {
          min = Math.min(min, arr[0]);
          max = Math.max(max, arr[0]);
      }
      
      let range = max - min + 1;
      
      // 创建桶数组，每个桶可能包含多个具有相同第一个元素的数组
      let buckets = new Array(range).fill(0).map(() => []);
      
      // 将数组放入对应的桶中
      for (let arr of arrays) {
          buckets[arr[0] - min].push(arr);
      }
      
      // 收集结果（降序）
      let result = [];
      for (let i = range - 1; i >= 0; i--) {
          if (buckets[i].length > 0) {
              // 将当前桶中的所有数组添加到结果中
              result.push(...buckets[i]);
          }
      }
      
      return result;
  }
  
  // 示例
  const arrays = [[1,1], [2,1], [3,2]];
  const sortedArrays = sortNestedArrays(arrays);
  console.log(sortedArrays); // 输出: [[3,2], [2,1], [1,1]]
  ```

## 高效删除数组中的某个元素

- 如果单纯使用来说，splice方法的做法更好

- 但是对于结合实际应用来看，splice方法反而是一个耗时做法，特别是你删除单个元素的时候

- **具体做法如下**

- （前置）此做法对于排序后无效

- 记录你要删除的元素的下标

- 将最后一个元素的值去覆盖你要删除的元素

- 使用pop方法删除最后一个元素

- ```js
  let delIndex = -1
  for(let i =0;i<nums.length;i++){
      // 比如要删除第四个元素
      if(i==3) delIndex = i
      nums[delIndex] = nums[nums.length-1]
      nums.pop()
  }
  ```

# 字符串

## `charCodeAt`和`codePointAt`方法

- 作用：获取字符串中字符的数值
- `charCodeAt`：返回Unicode，数值在0-65535，如果由两个 `UTF-16` 代码单元组成的字符，只会返回第一个代码单元的值
- `codePointAt`：返回指定位置字符的 Unicode，可以处理任何字符，包括由两个或多个 UTF-16 代码单元组成的字符
- 在选择上，`codePointAt`更加优解准确

```js
const str = '𠜎'; // 这是一个由两个 UTF-16 代码单元组成的字符

console.log(str.charCodeAt(0)); // 输出: 55362 (第一个代码单元)
console.log(str.charCodeAt(1)); // 输出: 57202 (第二个代码单元)

console.log(str.codePointAt(0)); // 输出: 20006 (完整的 Unicode 码点)
```

## `padEnd`方法

- 在字符串末尾填充指定的字符，默认为空格

`console.log(" ".padEnd(5));`

## repeat()方法

- 作用：将字符串重复指定次数，返回一个新的字符串
- 语法：`string.repeat(count)`

# `CSRF`

- CSRF：跨站请求伪造，是一种网络攻击方式，冒充用户发起合法请求，从而获得需要身份验证的敏感/加密数据

- 模拟CSRF攻击，加深CSRF的理解和使用

1. 服务端（后端代码准备）

   ```js
   const express = require('express');
   const cookieParser = require('cookie-parser');
   const cors = require('cors'); // 引入cors库
   const app = express();
   
   // 使用cors中间件，允许所有来源
   app.use(cors({
       origin: 'http://127.0.0.1:5500', // 允许5500端口的请求
       credentials: true // 允许cookie
   }));
   
   app.use(cookieParser());
   app.use(express.json());
   
   // 模拟用户数据
   const user = { id: 1, name: 'User', password: 'password' };
   
   // 登录路由，生成验证cookie
   app.post('/login', (req, res) => {
       const { username, password } = req.body;
       if (username === user.name && password === user.password) {
           res.cookie('auth', 'authenticated', {
               httpOnly: true,
               secure: false, // 确保开发环境下不强制HTTPS
               sameSite: 'None' // 推荐使用 Lax，跨域时仍然允许部分请求，None在生产环境需要HTTPS，所以secure要为true
           });
           res.send({ message: 'Logged in successfully' });
       } else {
           res.status(401).send({ message: 'Invalid credentials' });
       }
   });
   
   // 需要身份验证的受保护数据
   app.get('/protected-data', (req, res) => {
       if (req.cookies.auth === 'authenticated') {
           res.send({ data: 'Sensitive information only for logged-in users' });
       } else {
           res.status(403).send({ message: 'Not authenticated' });
       }
   });
   
   // 启动服务器
   app.listen(3000, () => {
       console.log('Server is running on http://127.0.0.1:3000');
   });
   ```

   > **注意**
   >
   > 在使用cookie的时候，严格要求前后端的主机名要一致，这里是127.0.0.1，如果前端是127.0.0.1，后端是localhost都不能在请求的时候携带cookie，但是能返回cookie

2. 前端html代码准备

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <title>Login Page</title>
   </head>
   
   <body>
       <h2>Login</h2>
       <form id="loginForm">
           <input type="text" id="username" placeholder="Username" required>
           <input type="password" id="password" placeholder="Password" required>
           <button type="submit">Login</button>
       </form>
   
       <h2>Protected Data</h2>
       <button id="getDataBtn">Get Protected Data</button>
       <p id="dataDisplay"></p>
   
       <script>
           document.getElementById('loginForm').addEventListener('submit', function (event) {
               event.preventDefault();
               const username = document.getElementById('username').value;
               const password = document.getElementById('password').value;
   
               fetch('http://127.0.0.1:3000/login', {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({ username, password }),
                   credentials: 'include' // 确保请求带上cookie
               })
                   .then(response => response.json())
                   .then(data => {
                       alert(data.message);
                   });
           });
   
           // 登录成功后，用户可以点击按钮获取受保护的数据。
           document.getElementById('getDataBtn').addEventListener('click', function () {
               fetch('http://127.0.0.1:3000/protected-data', {
                   method: 'GET',
                   headers: { 'Content-Type': 'application/json' },
                   credentials: 'include' // 确保请求带上cookie
               })
                   .then(response => response.json())
                   .then(data => {
                       document.getElementById('dataDisplay').textContent = JSON.stringify(data);
                   });
               // const xhr = new XMLHttpRequest();
               // xhr.withCredentials = true;
               // xhr.open('GET', 'http://localhost:3000/protected-data');
               // xhr.onload = function () {
               //     console.log(xhr.responseText);
               // };
               // xhr.send();
           });
       </script>
   </body>
   
   </html>
   ```

3. 启动服务器：`node server.js`

在没有登录的情况下是无法获取数据的

登录成功后，再次点击按钮即可获取数据

4. 准备攻击的html文件

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>CSRF Attack</title>
   </head>
   <body>
       <h2>CSRF Attack Page</h2>
   
       <script>
           // 模拟通过CSRF发起伪造的请求，带上用户的身份验证cookie
           fetch('http://127.0.0.1:3000/protected-data', {
               method: 'GET',
               headers: { 'Content-Type': 'application/json' },
               credentials: 'include' // 通过CSRF携带cookie模拟用户的请求
           })
           .then(response => response.json())
           .then(data => {
               console.log('Sensitive Data (via CSRF):', data); // 这里成功模拟了用户请求
           });
   
           // 模拟没有用户cookie的请求，不带任何身份验证信息
           fetch('http://127.0.0.1:3000/protected-data', {
               method: 'GET',
               credentials: 'omit' // 不带任何cookie，模拟无身份的请求
           })
           .then(response => {
               if (!response.ok) {
                   console.log('Failed to fetch data without authentication (No CSRF):', response.status);
               }
               return response.json();
           })
           .then(data => {
               console.log('Data without authentication (No CSRF):', data); // 这里没有返回数据，因为没有身份验证
           });
       </script>
   </body>
   </html>
   
   ```

5. 模拟攻击

直接运行网页，用户在打开这个网页的时候就会发起请求，此时用户并不知道，就根据登录过之前某个网站的cookie来获取数据了

# Vue

## cdn引入Vue

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            background: #0f3854;
            background: radial-gradient(ellipse at center, #0a2e38 0%, #000000 70%);
            background-size: 100%;
        }

        p {
            margin: 0;
            padding: 0;
        }

        #clock {
            font-family: 'Share Tech Mono', monospace;
            color: #ffffff;
            text-align: center;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #daf6ff;
            text-shadow: 0 0 20px rgba(10, 175, 230, 1), 0 0 20px rgba(10, 175, 230, 0);

            .time {
                letter-spacing: 0.05em;
                font-size: 80px;
                padding: 5px 0;
            }

            .date {
                letter-spacing: 0.1em;
                font-size: 24px;
            }

            .text {
                letter-spacing: 0.1em;
                font-size: 12px;
                padding: 20px 0 0;
            }
        }
    </style>
</head>

<body>
    <div id="clock">
        <p class="date">{{ date }}</p>
        <p class="time">{{ time }}</p>
        <p class="text">DIGITAL CLOCK with Vue.js</p>
    </div>

    <script>
        var clock = new Vue({
            el: '#clock',
            data: {
                time: '',
                date: ''
            }
        });

        var week = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        var timerID = setInterval(updateTime, 1000);
        updateTime();
        function updateTime() {
            var cd = new Date();
            clock.time = zeroPadding(cd.getHours(), 2) + ':' + zeroPadding(cd.getMinutes(), 2) + ':' + zeroPadding(cd.getSeconds(), 2);
            clock.date = zeroPadding(cd.getFullYear(), 4) + '-' + zeroPadding(cd.getMonth() + 1, 2) + '-' + zeroPadding(cd.getDate(), 2) + ' ' + week[cd.getDay()];
        };

        function zeroPadding(num, digit) {
            var zero = '';
            for (var i = 0; i < digit; i++) {
                zero += '0';
            }
            return (zero + num).slice(-digit);
        }
    </script>
</body>

</html>
```

# 引导功能

[`driver.js`](https://driverjs.cn/)

引导功能可以使用`driver.js`引导组件库

在很多网站，有需要引导用户进行操作的地方，这个时候就可以使用这个库来实现，而不用原生去写

根据官方文档，需要引入`cdn`（我这里采用`cdn`的方式，因为比较快）

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver.js 示例</title>
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        .button {
            margin: 20px;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .info {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>

<body>

    <h1>Driver.js 示例</h1>
    <button class="button" id="start-tour">开始引导</button>

    <div class="info" id="info1">这是信息框 1</div>
    <div class="info" id="info2">这是信息框 2</div>
    <div class="info" id="info3">这是信息框 3</div>
    <script>
        const driver = window.driver.js.driver;

        const driverObj = driver({
            showProgress: true,
            steps: [
                {
                    element: '#info1',
                    popover: {
                        title: '第一步',
                        description: '这是第一步的描述',
                    },
                },
                {
                    element: '#info2',
                    popover: {
                        title: '第二步',
                        description: '这是第二步的描述',
                    }
                }
            ]
        });
        document.getElementById('start-tour').addEventListener('click', () => {
            driverObj.drive();
        });

    </script>
</body>

</html>
```

这个时候你可以看到点击开始引导按钮的时候，就有引导的效果出来了

> **注意**
>
> `const driver = window.driver.js.driver;`
>
> `const driverObj = driver({})`
>
> `driverObj.drive();`
>
> 这三个是关键代码，少一个都不行
>
> 第一个是声明，第二个是定义引导的对象，第三个是启动

# 事件循环

## 浏览器的进程模型

### 进程

程序运行，有它自己的内存空间，这个内存空间就是进程

### 线程

有了进程，就能够运行代码

运行代码的人，就相当于线程

一个进程至少有一个线程，进程开启会自动创建一个线程来运行代码，这是主线程

一个进程可以包含多个线程，因为主线程忙不过来，需要其他线程帮忙做其他事，因为主线程不能同时做太多事，比如不能一边处理注册登录，又一边处理用户的操作，又一边处理其他用户的操作

### 浏览器的进程和线程

浏览器会自动启动多个进程，防止连环崩溃

- 浏览器进程、网络进程、**渲染进程**

其中一个崩溃，不会影响其他的进程

---

- **渲染进程**启动，会开启**渲染主线程**，负责执行HTML、`CSS`和`JS`代码

- 默认情况，每个标签页开启一个新的**渲染进程**

## 渲染主线程的工作

- 解析HTML
- 解析`CSS`
- 计算样式
- 布局
- 处理图层
- 每秒把页面画60次
- 执行全局`JS`代码
- 执行事件处理函数
- 执行计时器的回调函数
- ..........

> 为什么渲染进程不适用多个线程来处理这些事情？

```bash
渲染主线程在开始时，会进入一个无限循环

存在一个消息队列，其他线程的任务都会追加到这个队列里面去

每一次循环，渲染主线程都会检查队列中是否有任务，有就一一拿出来执行，没有就休眠

这就是事件循环，又称为消息循环，因为每一次都从消息队列里面中拿任务执行
```

## 若干解释

### 异步

- 计时：`setTimeout`、`setInterval`
- 网络通信：`XHR`、Fetch
- 用户操作：addEventListener

**浏览器作为极其重要的角色，处理很多东西，无论如何都不能阻塞**

因此浏览器用异步来解决问题

- 浏览器遇到计时任务
- 浏览器通知计时线程，然后任务结束
- 浏览器开始拿下一个任务……
- 计时线程完毕，把计时结束通知追加到消息队列里面
- 浏览器做到这个计时结束通知的任务
- 然后开始调用计时那个任务
- 完成任务，继续做下一个任务……

> 面试题：如何理解JS的异步？
>
> **`JS`是一门单线程语言**，它运行在浏览器的渲染主线程中，然而渲染主线程只有一个
>
> 渲染主线程工作很多，渲染页面、执行`JS`等，
>
> 使用同步，会导致主线程阻塞，消息队列许多任务无法执行，导致页面无法及时更新，页面卡死
>
> 所以具体做法，某些任务发生，像计时器、网络、事件监听等交给其他线程处理，自身立即结束任务的执行，执行后续的代码，当其他线程完成，**将事先传递的回调函数包装成任务**，加入到消息队列的末尾排队，等待主线程调度执行
>
> 在这种异步下，浏览器永远不阻塞，最大限度保证了单线程的流畅运行

### JS阻碍渲染的原因

- `JS`执行时间太长会导致渲染主线程无法绘制页面而导致页面卡死，阻碍了渲染

### 任务优先级

`W3C`

- 任务没有优先级，在消息队列中先进先出
- 消息队列可以有多个，同一类型的任务只能在同一个队列中
- **在一次事件循环中**，浏览器可以根据**实际情况**从不同的队列中取出任务执行

chrome队列

- 延时队列：存放计时器，优先级【中】
- 交互队列：存放用户操作，优先级【高】
- 微队列：存放最快执行任务，优先级【最高】

> 微队列使用方式：Promise、`MutationObserver`
>
> `Promise.resolve().then(函数)`：这段代码，函数直接会进入微队列

> 面试题：阐述`JS`事件循环
>
> 事件循环又称为消息循环，因为浏览器源码是message loop，官方文档给的是event loop
>
> 事件循环是浏览器渲染主线程的工作方式
>
> Chrome源码中，会开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，其他线程在合适的时候将任务加入到队列末尾
>
> 过去把消息队列分为微队列和宏队列，现在采用更加灵活多变的方式，浏览器自行决定取哪一个队列的任务，但是必须有一个微队列，并且它优先级最高
>
> **单线程是产生异步的原因**
>
> **事件循环是异步的实现方式**

> 面试题：`JS`中计时器能做到精确计时吗？为什么
>
> 不能
>
> 1、计算机硬件没有原子钟，硬件都做不到，`js`怎么做得到
>
> 2、操作系统计时函数本身有偏差，`js`的计时器调用操作系统函数，因此携带偏差
>
> 3、按照`W3C`标准，浏览器实现计时器，超过五层会带4毫秒
>
> 4、受事件循环影响，计时器回调函数只能在主线程空闲时运行

# 浏览器渲染

- 渲染是什么？
- 渲染即render，`vue`和react里的render就是虚拟DOM
- 浏览器的渲染，即把`html`字符串变成像素信息
- 渲染过程就是把每一个像素点的颜色保存下来，传递给显卡，让显卡绘制（如果没有显卡的情况下，有的可以用软件渲染，这里就由CPU完成）

> 面试题：浏览器是如何渲染页面的？
>
> 网络线程拿到HTML，会产生一个渲染任务，并将其传递给渲染主线程的消息队列
>
> 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

## 渲染时间点

网络线程拿到HTML，会产生一个渲染任务，并将其传递给渲染主线程的消息队列

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

## 渲染流水线

- 整个渲染流程阶段

HTML字符串 → 解析HTML → 样式计算 → 布局 → 分层 → 绘制 → 分块 → 光栅化 → 画 → 像素信息

- 解析HTML - Parse HTML

解析HTML就变成Parse HTML，它会生成两个树，分别是DOM树和`CSSOM`树

树在`JS`里面被称为对象，document就是典型的树

---

- 渲染第一步是解析HTML
- 解析过程中遇到`CSS`，会将它放到预下载中继续执行解析HTML
- 待`CSS`下载完毕后再执行
- 解析过程中遇到`JS`，会将它放到预下载中并等待下载完成，然后执行，因为`JS`可能会修改`DOM`
- 执行完`JS`后继续解析HTML

---

- 渲染的第二步是样式计算
- 最终看到的效果是计算后的最终结果（`F12`的Styles旁边有个Computed，可以看到）

# 歌词滚动

歌词素材

```js
var lrc = `[00:01.06]难念的经
[00:03.95]演唱：周华健
[00:06.78]
[00:30.96]笑你我枉花光心计
[00:34.15]爱竞逐镜花那美丽
[00:36.75]怕幸运会转眼远逝
[00:39.32]为贪嗔喜恶怒着迷
[00:41.99]责你我太贪功恋势
[00:44.48]怪大地众生太美丽
[00:47.00]悔旧日太执信约誓
[00:49.66]为悲欢哀怨妒着迷
[00:52.56]啊 舍不得璀灿俗世
[00:57.66]啊 躲不开痴恋的欣慰
[01:02.86]啊 找不到色相代替
[01:08.09]啊 参一生参不透这条难题
[01:13.15]吞风吻雨葬落日未曾彷徨
[01:15.73]欺山赶海践雪径也未绝望
[01:18.23]拈花把酒偏折煞世人情狂
[01:20.90]凭这两眼与百臂或千手不能防
[01:23.76]天阔阔雪漫漫共谁同航
[01:26.09]这沙滚滚水皱皱笑着浪荡
[01:28.68]贪欢一刻偏教那女儿情长埋葬
[01:32.38]
[01:34.09]吞风吻雨葬落日未曾彷徨
[01:36.50]欺山赶海践雪径也未绝望
[01:39.07]拈花把酒偏折煞世人情狂
[01:41.69]凭这两眼与百臂或千手不能防
[01:44.68]天阔阔雪漫漫共谁同航
[01:46.93]这沙滚滚水皱皱笑着浪荡
[01:49.54]贪欢一刻偏教那女儿情长埋葬
[01:53.41]
[02:15.45]笑你我枉花光心计
[02:18.53]爱竞逐镜花那美丽
[02:21.14]怕幸运会转眼远逝
[02:23.76]为贪嗔喜恶怒着迷
[02:26.43]责你我太贪功恋势
[02:28.98]怪大地众生太美丽
[02:31.60]悔旧日太执信约誓
[02:34.26]为悲欢哀怨妒着迷
[02:36.90]啊 舍不得璀灿俗世
[02:42.04]啊 躲不开痴恋的欣慰
[02:47.34]啊 找不到色相代替
[02:52.52]啊 参一生参不透这条难题
[02:57.47]吞风吻雨葬落日未曾彷徨
[03:00.05]欺山赶海践雪径也未绝望
[03:02.64]拈花把酒偏折煞世人情狂
[03:05.27]凭这两眼与百臂或千手不能防
[03:08.22]天阔阔雪漫漫共谁同航
[03:10.49]这沙滚滚水皱皱笑着浪荡
[03:13.06]贪欢一刻偏教那女儿情长埋葬
[03:18.45]吞风吻雨葬落日未曾彷徨
[03:20.90]欺山赶海践雪径也未绝望
[03:23.54]拈花把酒偏折煞世人情狂
[03:26.21]凭这两眼与百臂或千手不能防
[03:29.07]天阔阔雪漫漫共谁同航
[03:31.32]这沙滚滚水皱皱笑着浪荡
[03:33.92]贪欢一刻偏教那女儿情长埋葬
[03:39.32]吞风吻雨葬落日未曾彷徨
[03:41.84]欺山赶海践雪径也未绝望
[03:44.38]拈花把酒偏折煞世人情狂
[03:47.04]凭这两眼与百臂或千手不能防
[03:49.99]天阔阔雪漫漫共谁同航
[03:52.20]这沙滚滚水皱皱笑着浪荡
[03:54.89]贪欢一刻偏教那女儿情长埋葬
[04:00.28]吞风吻雨葬落日未曾彷徨
[04:02.68]欺山赶海践雪径也未绝望
[04:05.25]拈花把酒偏折煞世人情狂
[04:07.90]凭这两眼与百臂或千手不能防
[04:10.85]天阔阔雪漫漫共谁同航
[04:13.08]这沙滚滚水皱皱笑着浪荡
[04:15.75]贪欢一刻偏教那女儿情长埋葬
[04:19.48]`;
```

> **静态数据**可以通过**乱数假文(`lorem`)**来用于排版
>
> ```html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <title>Document</title>
>     <link rel="shortcut icon" type="image/x-icon" />
> </head>
> <body>
>     lorem30
> </body>
> </html>
> ```
>
> 输入`lorem30`，然后回车，就会生成30个乱数假文的单词
>
> ```html
> <!DOCTYPE html>
> <html lang="en">
> 
> <head>
>     <meta charset="UTF-8">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <title>Document</title>
>     <link rel="shortcut icon" type="image/x-icon" />
> </head>
> 
> <body>
>     Lorem ipsum dolor sit amet consectetur adipisicing elit. Velit, sit! Molestias asperiores unde, perspiciatis
>     eligendi officiis, deleniti nihil obcaecati incidunt, similique aperiam nam exercitationem eos a dicta expedita.
>     Culpa, perspiciatis!
> </body>
> 
> </html>
> ```

完整代码

index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="shortcut icon" href="./assets/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="./css/index.css" />
  </head>
  <body>
    <audio controls src="./assets/music.mp3"></audio>
    <div class="container">
      <ul class="lrc-list"></ul>
    </div>

    <script src="./js/data.js"></script>
    <script src="./js/index.js"></script>
  </body>
</html>
```

index.css

```css
* {
  margin: 0;
  padding: 0;
}

body {
  background: #000;
  color: #666;
  text-align: center;
}

audio {
  width: 450px;
  margin: 30px 0;
}

.container {
  height: 420px;
  overflow: hidden;
  /*// border: 2px solid #fff; */
}

.container ul {
  /*// border: 2px solid #fff; */
  transition: 0.6s;
  /*! 只针对数值类的属性有效，添加了这个属性后会对ul这个属性里的所有属性都进行动画效果 */
  list-style: none;
}

.container li {
  height: 30px;
  /*// border: 1px solid #fff; */
  line-height: 30px;
  /*! 过渡一般设置在一直存在的属性上 */
  transition: 0.2s;
}

.container li.active {
  color: #fff;
  /*// font-size: ; */
  transform: scale(1.2);
}
```

index.js

```js
//! 文档注释
//! 当你写了文档注释后，函数调用的时候，鼠标指向函数名，就会显示注释内容。
/** 
 * 解析歌词字符串
 * 得到一个歌词对象的数组
 * 每个歌词对象：
 * {time:开始时间, words: 歌词内容}
 */
function parseLrc() {
  var lines = lrc.split('\n');
  var result = []; // 歌词对象数组
  for (var i = 0; i < lines.length; i++) {
    var str = lines[i];
    var parts = str.split(']');
    var timeStr = parts[0].substring(1);
    var obj = {
      time: parseTime(timeStr),
      words: parts[1],
    };
    result.push(obj);
  }
  return result;
}

/**
 * 将一个时间字符串解析为数字（秒）
 * @param {String} timeStr 时间字符串
 * @returns
 */
function parseTime(timeStr) {
  var parts = timeStr.split(':');
  //! 这里的 + 号会自动转换为数字类型
  return +parts[0] * 60 + +parts[1];
}

var lrcData = parseLrc();

//todo 获取需要的 dom
//! 把dom元素放到对象当中，有利于防止变量名冲突
var doms = {
  audio: document.querySelector('audio'),
  ul: document.querySelector('.container ul'),
  container: document.querySelector('.container'),
};

/**
 * 计算出，在当前播放器播放到第几秒的情况下
 * lrcData数组中，应该高亮显示的歌词下标
 * 如果没有任何一句歌词需要显示，则得到-1
 */
function findIndex() {
  // 播放器当前时间
  var curTime = doms.audio.currentTime;
  for (var i = 0; i < lrcData.length; i++) {
    if (curTime < lrcData[i].time) {
      return i - 1;
    }
  }
  // 找遍了都没找到（说明播放到最后一句）
  return lrcData.length - 1;
}

// 界面

/**
 * 创建歌词元素 li
 */
function createLrcElements() {
  // 与dom树偏离
  var frag = document.createDocumentFragment(); // 文档片段
  for (var i = 0; i < lrcData.length; i++) {
    var li = document.createElement('li');
    li.textContent = lrcData[i].words;
    frag.appendChild(li); // 改动了 dom 树
  }
  doms.ul.appendChild(frag);
}

createLrcElements();

/**
 * 硬编码
 * 即将代码的值写死，这种做法的可维护性比较低，但是项目不能拒绝硬编码
 */

// 容器高度
var containerHeight = doms.container.clientHeight;
// 每个 li 的高度
var liHeight = doms.ul.children[0].clientHeight;
// 最大偏移量
var maxOffset = doms.ul.clientHeight - containerHeight;
/**
 * 设置 ul 元素的偏移量
 */
function setOffset() {
  var index = findIndex();
  var offset = liHeight * index + liHeight / 2 - containerHeight / 2;
  // 边界处理
  if (offset < 0) {
    offset = 0;
  }
  if (offset > maxOffset) {
    offset = maxOffset;
  }
  doms.ul.style.transform = `translateY(-${offset}px)`;
  // 去掉之前的 active 样式
  var li = doms.ul.querySelector('.active');
  if (li) {
    li.classList.remove('active');
  }

  li = doms.ul.children[index];
  if (li) {
    li.classList.add('active');
  }
}

// 时间改变事件
doms.audio.addEventListener('timeupdate', setOffset);
```

# 购物车

- 素材

index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>丑团外卖</title>
    <link rel="shortcut icon" href="./assets/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="./css/common.css" />
    <link rel="stylesheet" href="./css/container.css" />
    <link rel="stylesheet" href="./css/footer.css" />
    <link rel="stylesheet" href="./css/add-to-car.css" />
  </head>
  <body>
    <div class="container">
      <div class="menu">
        <div class="menu-item active"><span>推荐</span></div>
        <div class="menu-item"><span>热销</span></div>
        <div class="menu-item"><span>折扣</span></div>
        <div class="menu-item"><span>夏日冰咖必喝榜</span></div>
        <div class="menu-item"><span>进店必喝</span></div>
        <div class="menu-item"><span>只喝美式</span></div>
        <div class="menu-item"><span>酷爽特调水果冰萃</span></div>
        <div class="menu-item"><span>经典奶咖</span></div>
        <div class="menu-item"><span>创意奶咖</span></div>
        <div class="menu-item"><span>瑞纳冰季</span></div>
        <div class="menu-item"><span>不喝咖啡</span></div>
        <div class="menu-item"><span>轻食甜品</span></div>
        <div class="menu-item"><span>热卖套餐</span></div>
      </div>
      <div class="goods-list"></div>
    </div>
    <div class="footer">
      <div class="footer-car-container">
        <div class="footer-car">
          <i class="iconfont i-gouwuchefill"></i>
          <span class="footer-car-badge">0</span>
        </div>
        <div class="footer-car-price">
          <span class="footer-car-unit">￥</span>
          <span class="footer-car-total">0.00</span>
        </div>
        <div class="footer-car-tip">配送费￥0</div>
      </div>
      <div class="footer-pay">
        <a href="">去结算</a>
        <span>还差￥0元起送</span>
      </div>
    </div>

    <!-- <div class="add-to-car">
      <i class="iconfont i-jiajianzujianjiahao"></i>
    </div> -->

    <script src="./js/data.js"></script>
    <script src="./js/index.js"></script>
  </body>
</html>
```

add-to-car.css

```css
.add-to-car {
  position: fixed;
  color: #fff;
  font-size: 23rem;
  line-height: 40rem;
  text-align: center;
  z-index: 9;
  margin-left: -20rem;
  margin-top: -20rem;
  left: 0;
  top: 0;
  transition: 0.5s linear;
}

.add-to-car .iconfont {
  width: 40rem;
  height: 40rem;
  background: #4a90e1;
  border-radius: 50%;
  display: block;
  transition: 0.5s cubic-bezier(0.5, -0.5, 1, 1);
}
```

common.css

```css
@import url('https://at.alicdn.com/t/c/font_3555577_me2a6tdmvu8.css');

*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 0.125vw;
}
body {
  font-size: 35rem;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-smoothing: antialiased;
  user-select: none;
  font-family: 'Microsoft Yahei', 'sans-serif';
}
a {
  color: inherit;
  text-decoration: none;
}
.iconfont {
  font-size: inherit;
}
```

container.css

```css
.container {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: calc(100% - 100rem);
  display: flex;
  color: #333;
}
.menu {
  background: #f5f5f5;
  width: 190rem;
  overflow-y: scroll;
  padding-bottom: 50rem;
  flex: 0 0 auto;
}
.menu::-webkit-scrollbar {
  width: 0;
}

.menu-item {
  height: 141rem;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 30rem;
  position: relative;
}
.menu-item span {
  font-size: 30rem;
  line-height: 40rem;
  max-height: 80rem;
  overflow: hidden;
}
.menu-item.active {
  font-weight: bold;
  background: #fff;
}
.menu-item.active::before {
  content: '';
  position: absolute;
  left: 0;
  height: 100%;
  width: 7.5rem;
  background: #3190e8;
}

.goods-list {
  flex-grow: 1;
  overflow-y: scroll;
}
.goods-list::-webkit-scrollbar {
  width: 0;
}

.goods-item {
  border-bottom: 1rem solid #f8f8f8;
  padding: 30rem 20rem;
  display: flex;
}
.goods-pic {
  width: 200rem;
  height: 200rem;
  object-fit: contain;
  border: 1rem solid rgba(0, 0, 0, 0.06);
  flex: 0 0 auto;
}
.goods-info {
  flex: 1 1 auto;
  padding: 0 35rem;
  overflow: hidden;
}
.goods-title {
  font-size: 35rem;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-bottom: 20rem;
}
.goods-desc {
  font-size: 24rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 20rem;
}
.goods-sell {
  color: #858687;
  font-size: 24rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 20rem;
  display: flex;
}
.goods-sell span:first-child {
  margin-right: 18rem;
}
.goods-confirm {
  display: flex;
  justify-content: space-between;
}
.goods-price {
  display: flex;
  font-size: 35rem;
  font-weight: bold;
  color: #f60;
  align-items: flex-end;
}
.goods-price-unit {
  font-size: 25rem;
  margin-bottom: 4rem;
  font-weight: normal;
}
.goods-btns {
  display: flex;
  justify-content: center;
  align-items: center;
}
.goods-btns .iconfont {
  width: 40rem;
  height: 40rem;
  background: #4a90e1;
  color: #fff;
  border-radius: 50%;
  font-size: 23rem;
  line-height: 40rem;
  text-align: center;
}
.goods-btns span {
  margin: 0 15rem;
  display: none;
}
.goods-btns .i-jianhao {
  border: 1rem solid #4a90e1;
  background: #fff;
  color: #4a90e1;
  font-weight: bold;
  display: none;
}
.goods-item.active span {
  display: block;
}
.goods-item.active .i-jianhao {
  display: block;
}

```

footer.css

```css
.footer {
  height: 100rem;
  color: #fff;
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100%;
  display: flex;
  z-index: 10;
}

.footer-car-container {
  flex-grow: 1;
  background: #3d3d3f;
  padding-left: 175rem;
  position: relative;
}
.footer-car {
  position: absolute;
  width: 118rem;
  height: 118rem;
  border: 9rem solid #444;
  left: 25rem;
  top: -35rem;
  border-radius: 50%;
  background: inherit;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 60rem;
}
.footer-car-badge {
  position: absolute;
  width: 35rem;
  height: 35rem;
  background: #ec5533;
  font-size: 25rem;
  text-align: center;
  border-radius: 50%;
  line-height: 35rem;
  right: 0;
  top: 0;
  display: none;
}
.footer-car.active {
  background: #4a90e1;
}
.footer-car.active .footer-car-badge {
  display: block;
}
.footer-car.animate {
  animation: footer-car-animate 500ms ease-in-out;
}

@keyframes footer-car-animate {
  0% {
    transform: scale(1);
  }
  25% {
    transform: scale(0.8);
  }
  50% {
    transform: scale(1.1);
  }
  75% {
    transform: scale(0.9);
  }
  100% {
    transform: scale(1);
  }
}

.footer-car-price {
  font-size: 40rem;
  display: flex;
  margin-top: 5rem;
}
.footer-car-tip {
  font-size: 20rem;
  margin-left: 6rem;
}
.footer-pay {
  background: #535356;
  width: 250rem;
  font-size: 35rem;
  line-height: 100rem;
  text-align: center;
}
.footer-pay > * {
  display: block;
  width: 100%;
  height: 100%;
}
.footer-pay a {
  display: none;
}
.footer-pay span {
  font-size: 30rem;
}
.footer-pay.active {
  background: #76d572;
}
.footer-pay.active a {
  display: block;
}
.footer-pay.active span {
  display: none;
}

```

data.js

```js
var goods = [
  {
    pic: './assets/g1.png',
    title: '椰云拿铁',
    desc: `1人份【年度重磅，一口吞云】
    √原创椰云topping，绵密轻盈到飞起！
    原创瑞幸椰云™工艺，使用椰浆代替常规奶盖
    打造丰盈、绵密，如云朵般细腻奶沫体验
    椰香清甜饱满，一口滑入口腔
    
    【饮用建议】请注意不要用吸管，不要搅拌哦~`,
    sellNumber: 200,
    favorRate: 95,
    price: 32,
  },
  {
    pic: './assets/g2.png',
    title: '生椰拿铁',
    desc: `1人份【YYDS，无限回购】
    现萃香醇Espresso，遇见优质冷榨生椰浆，椰香浓郁，香甜清爽，带给你不一样的拿铁体验！
    
    主要原料：浓缩咖啡、冷冻椰浆、原味调味糖浆
    图片及包装仅供参考，请以实物为准。建议送达后尽快饮用。到店饮用口感更佳。`,
    sellNumber: 1000,
    favorRate: 100,
    price: 19.9,
  },
  {
    pic: './assets/g3.png',
    title: '加浓 美式',
    desc: `1人份【清醒加倍，比标美多一份Espresso】
    口感更佳香醇浓郁，回味持久
    图片仅供参考，请以实物为准。建议送达后尽快饮用。`,
    sellNumber: 200,
    favorRate: 93,
    price: 20.3,
  },
  {
    pic: './assets/g4.png',
    title: '瓦尔登蓝钻瑞纳冰',
    desc: `1人份【爆款回归！蓝色治愈力量】
    灵感来自下澄明、碧蓝之境---瓦尔登湖。含藻蓝蛋白，梦幻蓝色源自天然植物成分，非人工合成色素，融入人气冷榨生椰浆，椰香浓郁，清冽冰爽；底部添加Q弹小料，0脂原味晶球，光泽剔透，如钻石般blingbling。搭配奶油顶和彩虹色棉花糖，满足你的少女心～
    【去奶油小提示】由于去掉奶油后顶料口味会受影响，为保证口感，选择“去奶油”选项时将同时去掉奶油及顶料，请注意哦！【温馨提示】瑞纳冰系列产品形态为冰沙，无法进行少冰、去冰操作，请您谅解。【图片仅供参考，请以实物为准】`,
    sellNumber: 17,
    favorRate: 80,
    price: 38,
  },
  {
    pic: './assets/g5.png',
    title: '椰云精萃美式',
    desc: `1人份【不用吸管 大口吞云！】

    1杯热量*≈0.6个苹果！
    原创瑞幸椰云™工艺，将「椰浆」变成绵密、丰盈的“云朵”，口感绵密顺滑！0乳糖植物基，清爽轻负担！
    
    *数据引自《中国食物成分表》第六版，苹果每100克可食部分中能量约为53千卡，以每个苹果250克/个计，1杯椰云精萃美式约80千卡，相当于约0.6个苹果。
    【图片仅供参考，请以实物为准】`,
    sellNumber: 50,
    favorRate: 90,
    price: 21.12,
  },
];

```

- 本次学习，只有手动编写index.js代码的部分，其余全是素材

index.js

```js
/**
 * 开发思想：
 * 1、编写数据
 * 2、编写UI，UI是基于数据而来的
 * 3、编写功能
 * 4、编写事件
 */

// 单件商品的数据
class UIGoods {
  constructor(g) {
    this.data = g;
    this.choose = 0;
  }
  // 获取总价
  getTotalPrice() {
    return this.data.price * this.choose;
  }
  // 是否选中了此件商品
  isChoose() {
    return this.choose > 0;
  }
  // 选择的数量+1
  increase() {
    this.choose++;
  }
  // 选择的数量-1
  decrease() {
    if (this.choose === 0) {
      return;
    }
    this.choose--;
  }
}

// 整个界面的数据
class UIData {
  constructor() {
    var uiGoods = [];
    for (var i = 0; i < goods.length; i++) {
      var uig = new UIGoods(goods[i]);
      uiGoods.push(uig);
    }
    this.uiGoods = uiGoods;
    // 配送门槛费
    this.deliveryThreshold = 30;
    // 配送费
    this.deliveryPrice = 5;
  }

  getTotalPrice() {
    var sum = 0;
    for (var i = 0; i < this.uiGoods.length; i++) {
      var g = this.uiGoods[i];
      sum += g.getTotalPrice();
    }
    return sum;
  }

  // 增加某件商品的选中数量
  increase(index) {
    this.uiGoods[index].increase();
  }
  // 减少某件商品的选中数量
  decrease(index) {
    this.uiGoods[index].decrease();
  }

  // 得到总共的选择数量
  getTotalChooseNumber() {
    var sum = 0;
    for (var i = 0; i < this.uiGoods.length; i++) {
      sum += this.uiGoods[i].choose;
    }
    return sum;
  }

  // 购物车中有没有东西
  hasGoodsInCar() {
    return this.getTotalChooseNumber() > 0;
  }

  // 是否跨过了起送标准
  isCrossDeliveryThreshold() {
    return this.getTotalPrice() >= this.deliveryThreshold;
  }

  isChoose(index) {
    return this.uiGoods[index].isChoose();
  }
}

// 整个界面
class UI {
  constructor() {
    this.uiData = new UIData();
    this.doms = {
      goodsContainer: document.querySelector('.goods-list'),
      deliveryPrice: document.querySelector('.footer-car-tip'),
      footerPay: document.querySelector('.footer-pay'),
      footerPayInnerSpan: document.querySelector('.footer-pay span'),
      totalPrice: document.querySelector('.footer-car-total'),
      car: document.querySelector('.footer-car'),
      badge: document.querySelector('.footer-car-badge'),
    };
    var carRect = this.doms.car.getBoundingClientRect();

    var jumpTarget = {
      x: carRect.left + carRect.width / 2,
      y: carRect.top + carRect.height / 5,
    };
    this.jumpTarget = jumpTarget;

    this.createHTML();
    this.updateFooter();
    this.listenEvent();
  }

  // 监听各种事件
  listenEvent() {
    this.doms.car.addEventListener('animationend', function () {
      this.classList.remove('animate');
    });
  }

  // 根据商品数据创建商品列表元素
  createHTML() {
    var html = '';
    for (var i = 0; i < this.uiData.uiGoods.length; i++) {
      var g = this.uiData.uiGoods[i];
      html += `<div class="goods-item">
      <img src="${g.data.pic}" alt="" class="goods-pic">
      <div class="goods-info">
        <h2 class="goods-title">${g.data.title}</h2>
        <p class="goods-desc">${g.data.desc}</p>
        <p class="goods-sell">
          <span>月售 ${g.data.sellNumber}</span>
          <span>好评率${g.data.favorRate}%</span>
        </p>
        <div class="goods-confirm">
          <p class="goods-price">
            <span class="goods-price-unit">￥</span>
            <span>${g.data.price}</span>
          </p>
          <div class="goods-btns">
            <i index="${i}" class="iconfont i-jianhao"></i>
            <span>${g.choose}</span>
            <i index="${i}" class="iconfont i-jiajianzujianjiahao"></i>
          </div>
        </div>
      </div>
    </div>`;
    }
    this.doms.goodsContainer.innerHTML = html;
  }

  increase(index) {
    this.uiData.increase(index);
    this.updateGoodsItem(index);
    this.updateFooter();
    this.jump(index);
  }

  decrease(index) {
    this.uiData.decrease(index);
    this.updateGoodsItem(index);
    this.updateFooter();
  }
  // 更新某个商品元素的显示状态
  updateGoodsItem(index) {
    // 获取当前商品的DOM
    var goodsDom = this.doms.goodsContainer.children[index];
    if (this.uiData.isChoose(index)) {
      goodsDom.classList.add('active');
    } else {
      goodsDom.classList.remove('active');
    }
    var span = goodsDom.querySelector('.goods-btns span');
    span.textContent = this.uiData.uiGoods[index].choose;
  }
  // 更新页脚
  updateFooter() {
    // 得到总价数据
    var total = this.uiData.getTotalPrice();
    // 设置配送费
    this.doms.deliveryPrice.textContent = `配送费￥${this.uiData.deliveryPrice}`;
    // 设置起送费还差多少
    if (this.uiData.isCrossDeliveryThreshold()) {
      // 到达起送点
      this.doms.footerPay.classList.add('active');
    } else {
      this.doms.footerPay.classList.remove('active');
      // 更新还差多少钱
      var dis = this.uiData.deliveryThreshold - total;
      dis = Math.round(dis);
      this.doms.footerPayInnerSpan.textContent = `还差￥${dis}元起送`;
    }
    // 设置总价
    this.doms.totalPrice.textContent = total.toFixed(2);
    // 设置购物车的样式状态
    if (this.uiData.hasGoodsInCar()) {
      this.doms.car.classList.add('active');
    } else {
      this.doms.car.classList.remove('active');
    }
    // 设置购物车中的数量
    this.doms.badge.textContent = this.uiData.getTotalChooseNumber();
  }

  // 购物车动画
  carAnimate() {
    this.doms.car.classList.add('animate');
  }
  // 抛物线跳跃的元素
  jump(index) {
    // 找到对应商品的加号
    var btnAdd = this.doms.goodsContainer.children[index].querySelector(
      '.i-jiajianzujianjiahao'
    );
    // 得到加号的位置信息
    var rect = btnAdd.getBoundingClientRect();
    var start = {
      x: rect.left,
      y: rect.top,
    };
    // 跳吧
    var div = document.createElement('div');
    div.className = 'add-to-car';
    var i = document.createElement('i');
    i.className = 'iconfont i-jiajianzujianjiahao';
    // 设置初始位置
    // 为什么不能直接设置div来调整xy，要div来调整x，i来调整y？？？
    // 因为div的transform属性会影响i的位置
    // 为了达到抛物线，需要设置div的transform属性，然后让i的transform属性跟随div的transform属性变化
    div.style.transform = `translateX(${start.x}px)`;
    i.style.transform = `translateY(${start.y}px)`;
    div.appendChild(i);
    document.body.appendChild(div);
    // 提供一个布局属性，都能导致强行渲染，最好使用requesetAnimationFrame
    div.clientWidth;

    // 设置结束位置
    div.style.transform = `translateX(${this.jumpTarget.x}px)`;
    i.style.transform = `translateY(${this.jumpTarget.y}px)`;
    var that = this;
    div.addEventListener(
      'transitionend',
      function () {
        div.remove();
        that.carAnimate();
      },
      {
        once: true, // 事件仅触发一次
      }
    );
  }
}

var ui = new UI();

// 事件
ui.doms.goodsContainer.addEventListener('click', function (e) {
  if (e.target.classList.contains('i-jiajianzujianjiahao')) {
    var index = +e.target.getAttribute('index');
    ui.increase(index);
  } else if (e.target.classList.contains('i-jianhao')) {
    var index = +e.target.getAttribute('index');
    ui.decrease(index);
  }
});

window.addEventListener('keypress', function (e) {
  if (e.code === 'Equal') {
    ui.increase(0);
  } else if (e.code === 'Minus') {
    ui.decrease(0);
  }
});
```

# 属性描述符

- 作用：解决数据被篡改问题

```js
var obj = {
    a:1
}

class Test{
    constructor(g){
        this.g = g
    }
}

var test = new(obj)
test.g = 'test'
cosole.log(test.g) // test
```

- 获取属性描述符：`Object.getOwnPropertyDescriptor()`

- 设置属性描述符：`Object.defineProperty()`，通过这种方式不可重写，不可遍历

- 通过设置属性描述符，上面的做法就不能够被篡改

- `var desc = Object.getOwnPropertyDescriptor(obj,'a') `

- ```js
  Object.defineProperty(obj,'a'{
  	value:10,
  	writable:false, // 不能重写
  	enumerable:false, // 不能遍历
  	configurable:false, // 不能修改描述符本身
  })
  ```

```js
class UIGoods{
    constructor(g){
        Object.defineProperty(this,'data',{
            value:g,
            writable:false, // 不能重写
            enumerable:false, // 不能遍历
            configurable:false, // 不能修改描述符本身
    	})
    }
}
```

---

- 如果在属性描述符添加set和get方法，在读取属性的时候就是调用get方法

# 运算符

## 换位运算符

- &：按位与，两个二进制位为1则1，否则为0
- `5 & 3` 的计算过程如下：

```bash
数字5的二进制形式是 0101。
数字3的二进制形式是 0011。
按位与操作的结果是 0001，即十进制的1。
```

# 时间复杂度和空间复杂度

## 时间复杂度

- 最优按降序排列
- O(log n)
- O(n)：Math.min()
- O(`n log n`)：sort()

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    for (let i = m, j = 0; j < nums2.length; i++, j++) {
        nums1[i] = nums2[j]
    }

    // 升序
    // nums1.sort((a, b) => {
    //     return a - b
    // })

    // 优化排序
    let min = Math.min(...nums1); // 找到最小值
    let max = Math.max(...nums1); // 找到最大值
    let range = max - min + 1;  // 计算范围大小

    let count = new Array(range).fill(0); // 创建计数数组

    // 统计每个数出现的次数
    for (let num of nums1) {
        count[num - min]++; // 关键：用 num - min 作为索引，偏移负数
    }

    // 【1,2,3,2,5,6】  1 ---- 6
    // count 【1，2，1，0，1，1】

    // [-1,0,0,3,3,3,1,2,2]  -1 ----- 3
    // count 【0，……】

    // 还原排序数组
    let index = 0;
    for (let i = 0; i < range; i++) {
        while (count[i] > 0) {
            nums1[index++] = i + min; // 恢复原值
            count[i]--;
        }
    }
};
```

- for 里面有个 while，为什么时间复杂度是 O（n）
- 因为 while 里面有一个 count[i]--，count 数组 是对原数组进行计数
- while 的循环的总次数就是原数组的个数，假设原数组长度是 7，整个 for 和 while 嵌套也就执行 7 次循环，并不是 7*7=49 次，因此并不是 n²
- 相当于用 for 和 while 来将 n 拆开执行，并不是嵌套两层 n

## 空间复杂度

- O(1)：二分法
- O(n)：`Maht.min()`
- 二分法，基本就是left和right两个变量来处理数组，可以说是常数级别了

# 判断

- 判断是否有数字，使用`/\d/`
- 它能够判断字符或者字符串中是否包含数字
- 语法：`/\d/.test(char)`

# Map对象

## 排序

- 对map 对象的第二个元素进行降序

```js
var topKFrequent = function (nums, k) {
    const m = new Map()

    // 统计每个元素的个数
    for (const e of nums) {
        m.set(e, (m.get(e) || 0) + 1)
    }

    // 排序，这是想要的排序结果
    const arr = Array.from(m).sort((a, b) => { return b[1] - a[1] })

    // 返回排序后的前 k 个高频元素
    return arr.slice(0, k).map(item => item[0])
};
```

# DevTools

- 使用chrome的`DevTools`开发工具调试项目，是`console.log`调试的进阶，小型企业的做法其实还是`console.log`调试，你学会的`DevTools`秒杀它们噢
- 对于大型项目解构和debug来说，无需总览全局代码，能够快速找到核心以及问题所在
- 当然它也有提供事件监听，断点功能，你知道断点调试是后端进阶的手段

- 通过事件监听，`DevTools`就会在click点击事件监听器执行的第一行暂停，开始你的调试之旅
- 当然如果你不知道事件的情况下，全部勾选是最好的，但是你可能要一段时间找到你想要调试的地方（停错行）
- 接下来是逐行调试，是后端常见的断点之后逐步执行

- 如果你觉得这个函数没有问题，你可以跳过这个函数

- 它会直接跳到当前运行函数的最后
- 注意，如果你在不是函数的地方使用它的话，会跳到报错的地方，我推测是`DevTools`使用失误的报错处理
- 下一个和上面的有点相似，但它不是跳到当前运行函数的最后，而是结束当前运行函数
- 这个是在你觉得这个函数没有问题并且与错误没有关联的时候执行

- 万物归心，断点来了，如何断点，只要点击行号就行

- 然后恢复脚本执行，它就会执行到你断点的位置，如果不能恢复的话，说明你还没开始DevTools
- 开启`DevTools`应该会有标志的

- 调用堆栈，Call Stack，点击里面的各个函数，可以查看每个函数的调用位置

- 作用域，Scope，能够查看你的当前定义的所有本地和局部变量，能点击值来编辑这些变量

- 监视，Watch，能够去获得某个变量的类型，比如点击“+”添加一个 `typeof result`

- 当找到问题所在的时候，可以通过控制台去调试，如果调试没问题后，可以在`DevTools`里面编辑来验证
- 当然如果你的文件是只读，那就没办法编辑，需要给权限
- 在page里右键该文件，然后选择重写内容，然后选中你的项目文件夹，提供完整的读写权限
- 注意，它这里可能会创一个文件夹来保存你这个文件，相当于复制了
- 如果你足够自信就在自己的文件那里改，注意你的修改是会直接影响源文件的





